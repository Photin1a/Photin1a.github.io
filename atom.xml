<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Photinia</title>
  
  
  <link href="https://photin1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://photin1a.github.io/"/>
  <updated>2025-02-08T15:14:00.000Z</updated>
  <id>https://photin1a.github.io/</id>
  
  <author>
    <name>Photinia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录算法训练第三十二天|455分发饼干|376摆动序列|53最大子序和</title>
    <link href="https://photin1a.github.io/posts/f7631cda.html"/>
    <id>https://photin1a.github.io/posts/f7631cda.html</id>
    <published>2025-02-08T08:20:00.000Z</published>
    <updated>2025-02-08T15:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a></h1><blockquote><p><font color=red><strong>贪心算法其实就是没有什么规律可言。</strong></font>没有思路就立刻看题解。<br>基本贪心的题目有两个极端，要不就是特简单，要不就是死活想不出来。</p></blockquote><p><strong>贪心的本质</strong>：贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p><h2 id="什么时候用贪心">什么时候用贪心</h2><p>贪心算法并没有固定的套路。就是常识性推导加上举反例子。刷题或者面试的时候，<strong>手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例</strong>，那么就试一试贪心。</p><h2 id="贪心一般解题步骤">贪心一般解题步骤</h2><p>做题的时候，只要想清楚 <strong>局部最优</strong> 是什么，如果推导出全局最优，其实就够了。</p><h1>1、455分发饼干</h1><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p><p><strong>我的思路</strong>：我想每个人在饼干里找离他最能饱饼干，把饼干排序，这样查找时快一些。测试了一下 <code>21/25超时</code>。结果应该是对的，但是超时。于是我把食量也排序，这样找过的饼干前面的就不看了，<code>23/25超时</code>还是超时。<br><strong><a href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：人<strong>从后往前遍历</strong>找饼干。简便了很多。下图1是代码随想录的，从后往前只需看当前饼干能不能满足孩子胃口，不能那这个孩子就不用看了，往前的饼干也不可能满足。很经典。。图1是我的，从前往后，当前饼干不满足孩子胃口，但是后面的饼干更大，可能满足，我还得接着遍历饼干，时间复杂度更高。<br><img src="./f7631cda/tanxin.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 23/25 超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(s.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">            std::<span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">            std::<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;g.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = lastj;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="comment">// if(used[j] == true)continue;</span></span><br><span class="line">                    <span class="keyword">if</span>(s[j] &lt; g[i])<span class="keyword">continue</span>;</span><br><span class="line">                    used[j] = <span class="literal">true</span>;</span><br><span class="line">                    num++;</span><br><span class="line">                    lastj = j<span class="number">+1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">            std::<span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">            std::<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = g.<span class="built_in">size</span>()<span class="number">-1</span>, j = s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; <span class="number">0</span> || s[j] &lt; g[i])<span class="keyword">continue</span>;</span><br><span class="line">                num++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、376摆动序列</h1><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。<br>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><p><strong>我的思路</strong>：没做出来。这题暂时不做了。贪心。<br><strong><a href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。<br>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、53最大子序和</h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6</p><p><strong>我的思路</strong>：没做出来。贪心真的想不到。只能用用回溯做。<br><strong><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。全局最优：选取最大“连续和”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) &#123; <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) count = <span class="number">0</span>; <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html&quot;&gt;理论基础&lt;/a&gt;&lt;/h1&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="贪心算法" scheme="https://photin1a.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三十一天|491递增子序列|46全排列|47全排列II|332重新安排行程|51N皇后|37解数独</title>
    <link href="https://photin1a.github.io/posts/31c2c19.html"/>
    <id>https://photin1a.github.io/posts/31c2c19.html</id>
    <published>2025-02-08T05:43:00.000Z</published>
    <updated>2025-02-08T08:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、491递增子序列</h1><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>我的思路</strong>：没做出来。这道题返回的是序列，并不允许重新排序，所以这道题不好对树层进行去重。<br><strong>代码随想录</strong>：可以每一层迭代/递归都用一个 <code>unordered_set</code> 去统计出现过的元素。下一次直接判断元素是否出现过即可。<br><strong>优化</strong>：注意题目中说了，数值范围[-100,100]。所以可以用数组直接来做Hash查询，会比set快很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startidx,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(startidx &gt;= nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())<span class="keyword">continue</span>; <span class="comment">// 剪枝，递减序列</span></span><br><span class="line">                <span class="keyword">if</span>(uset.<span class="built_in">find</span>(nums[i])!=uset.<span class="built_in">end</span>())<span class="keyword">continue</span>; <span class="comment">//剪枝，用uset去重</span></span><br><span class="line">                uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startidx,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(startidx &gt;= nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> uset[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//使用&#123;&#125;初始化，没有初始化的元素将被初始化为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())<span class="keyword">continue</span>; <span class="comment">// 剪枝，递减序列</span></span><br><span class="line">                <span class="keyword">if</span>(uset[nums[i]<span class="number">+100</span>]==<span class="number">1</span>)<span class="keyword">continue</span>; <span class="comment">//剪枝，用uset去重</span></span><br><span class="line">                uset[nums[i]<span class="number">+100</span>]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h1>2、46全排列</h1><p>给定一个<strong>不含重复数字</strong>的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p><strong>我的思路</strong>：组合和排列有很明显的区别，组合不走回头路[1,2]和[2,1]是一样的，但是对于排列确是两种不同的序列。所以<strong>组合不走回头路，排列可以走回头路</strong>。</p><ul><li>走回头路意味着不需要<code>startidx</code>记录起始索引</li><li>和组合一样，同一候选元素不能多次使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; &amp;used, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、47全排列II</h1><p>给定一个可<strong>包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p><strong>我的思路</strong>：和<code>46全排列</code>不同，这题候选元素可能包含重复数字，所以需要<strong>树层去重</strong>，去重逻辑和组合一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; &amp;used, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)<span class="keyword">continue</span>;<span class="comment">// 排列特有的，树枝元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)<span class="keyword">continue</span>; <span class="comment">//树层去重</span></span><br><span class="line">            path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>; </span><br><span class="line">            </span><br><span class="line">            std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、332重新安排行程</h1><blockquote><p>二刷再做</p></blockquote><h1>5、51N皇后</h1><blockquote><p>二刷再做</p></blockquote><h1>6、37解数独</h1><blockquote><p>二刷再做</p></blockquote><h1><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><strong>代码随想录-回溯总结篇</strong></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、491递增子序列&lt;/h1&gt;
&lt;p&gt;给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。&lt;/p&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="排列-组合" scheme="https://photin1a.github.io/tags/%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三十天|93复原IP地址|78子集|90子集II</title>
    <link href="https://photin1a.github.io/posts/9d8f50cc.html"/>
    <id>https://photin1a.github.io/posts/9d8f50cc.html</id>
    <published>2025-02-08T04:00:00.000Z</published>
    <updated>2025-02-08T05:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、93复原IP地址</h1><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,“255.255.111.35”]</li></ul><p><strong>我的思路</strong>：<code>131分割回文串</code>类似，这道题是分割IP地址。不是回文串的就要剪枝，这题同样不是有效的IP元素的也要剪枝。先写出多叉树，再写递归逻辑。<font color = red><strong>遇到回溯的题先在纸上把问题画为多叉树演化一遍，不然很多细节想不到。</strong></font></p><p><strong><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：在原串上插入&quot;.&quot;来分割，不新建串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(string &amp;s,<span class="type">int</span> startidx, <span class="type">int</span> depth, string &amp;path, vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(startidx == s.<span class="built_in">size</span>())&#123; <span class="comment">// 截止条件，搜索完IP</span></span><br><span class="line">                <span class="keyword">if</span>(depth == <span class="number">5</span>)&#123; <span class="comment">// 检查IP是否四个段</span></span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(path.<span class="built_in">substr</span>(<span class="number">0</span>,path.<span class="built_in">size</span>()<span class="number">-1</span>));<span class="comment">// remove &quot;.&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(depth == <span class="number">4</span>)&#123;</span><br><span class="line">                    i = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isIPItem</span>(s,startidx,i))<span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="type">int</span> sub_size = i-startidx<span class="number">+1</span>; </span><br><span class="line">                path.<span class="built_in">append</span>(s,startidx,sub_size);</span><br><span class="line">                path+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                <span class="built_in">traverse</span>(s,i<span class="number">+1</span>,depth<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>(); <span class="comment">// remove &quot;.&quot;</span></span><br><span class="line">                path.<span class="built_in">erase</span>(path.<span class="built_in">size</span>()-sub_size,sub_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isIPItem</span><span class="params">(string &amp;s,<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start != end &amp;&amp; s[start]==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 0x 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>((end-start)&gt;<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//剪枝，最大范围255为三位</span></span><br><span class="line">            cout &lt;&lt; end-start &lt;&lt;endl;</span><br><span class="line">            <span class="type">int</span> ipitem = std::<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(start,end-start<span class="number">+1</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &gt; ipitem || ipitem &gt; <span class="number">255</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            string path;</span><br><span class="line">            vector&lt;string&gt; res;</span><br><span class="line">            <span class="built_in">traverse</span>(s,<span class="number">0</span>,<span class="number">1</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result;<span class="comment">// 记录结果</span></span><br><span class="line">    <span class="comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123; <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">            <span class="comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, i)) &#123; <span class="comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>);  <span class="comment">// 在i的后面插入一个逗点</span></span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointNum);   <span class="comment">// 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">                pointNum--;                         <span class="comment">// 回溯</span></span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);         <span class="comment">// 回溯删掉逗点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 不合法，直接结束本层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123; <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> result; <span class="comment">// 算是剪枝了</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、78子集</h1><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的<br>子集（幂集）。解集不能包含重复的子集。你可以按 任意顺序 返回解集。</p><p><strong>我的思路</strong>：典型的组合问题。由于组合的个数没有限制，所以不需要往后剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startidx,vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">if</span>(startidx == nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、90子集II</h1><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的<br>子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><strong>我的思路</strong>：与<code>78子集</code>不同，这题的候选元素有重复。候选元素重复要考虑<strong>树层去重</strong>和<strong>树枝去重</strong>两种情况。这里单个子集中的元素可以重复，例如[1,2,2]，实际上两个2来自两个不同的元素。<strong>所以这题只用树层去重</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startidx, vector&lt;<span class="type">bool</span>&gt; &amp;used, vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">if</span>(startidx &gt;= nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; used[i<span class="number">-1</span>]==<span class="literal">false</span>)<span class="keyword">continue</span>; </span><br><span class="line">                path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,used,path,res);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,used,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、93复原IP地址&lt;/h1&gt;
&lt;p&gt;有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="组合" scheme="https://photin1a.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十九天|39组合总和|40组合总和II|131分割回文串</title>
    <link href="https://photin1a.github.io/posts/81a907dc.html"/>
    <id>https://photin1a.github.io/posts/81a907dc.html</id>
    <published>2025-02-05T10:35:00.000Z</published>
    <updated>2025-02-05T10:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、39组合总和</h1><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>提示：</p><ul><li>2 &lt;= candidates[i] &lt;= 40 ==&gt;意味着不会出现0，导致无穷多组合计；全为正意味着sum递增，不会出现一直递归下去的情况，总会遇到target边界。</li></ul><p><strong>我的思路</strong>：这道题和一般的组合不同。数字可以重复选取，意味着j可以从i开始，k可以从j开始，因此也不需要剪枝。另一点是这道题递归的层数并不固定，找到target就返回。 下面是组合的框架，只适用于候选元素互不相同时。<br><img src="./81a907dc/combinnation.jpg" alt=""><br><a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> startidx,<span class="type">int</span> sum, <span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)<span class="keyword">return</span>; <span class="comment">// 截止条件，由于元素&gt;0，所以继续递归下去不会出现sum == target了</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123; </span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(candidates,i,sum+candidates[i],target,path,res); <span class="comment">// 不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">traverse</span>(candidates,<span class="number">0</span>,<span class="number">0</span>,target,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、40组合总和II</h1><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p><strong>我的思路</strong>：和上一题<code>39组合总和</code>不同，这题候选元素有重复，则带重复元素的组合也会有重复。所以<strong>需要去重</strong>。另外元素不允许多次选取。<br><strong><a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：去重，其实就是 <strong>(单层for循环内/递归同一深度)</strong> 使用过的元素不能重复选取。我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。强调一下，树层去重的话，需要对数组排序！<br><img src="./81a907dc/combin_repeat.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,vector&lt;<span class="type">bool</span>&gt; &amp;used, <span class="type">int</span> startidx,<span class="type">int</span> sum, <span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)<span class="keyword">return</span>; <span class="comment">// 截止条件，由于元素&gt;0，所以继续递归下去不会出现sum == target了</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123; </span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(candidates,used,i<span class="number">+1</span>,sum+candidates[i],target,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        std::<span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">traverse</span>(candidates,used,<span class="number">0</span>,<span class="number">0</span>,target,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、131分割回文串</h1><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。</p><ul><li>输入：s = “aab”</li><li>输出：[[“a”,“a”,“b”],[“aa”,“b”]]</li></ul><p><strong>我的思路</strong>：先用多叉树表示出分割的过程。然后使用回溯的递归框架就可以。<br><img src="./81a907dc/huiwen.jpg" alt=""><br><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(string &amp;s,<span class="type">int</span> startidx, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startidx == s.<span class="built_in">size</span>())&#123; <span class="comment">// 截止条件，搜索完回文串</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isHuiwen</span>(s,startidx,i))<span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            path.<span class="built_in">emplace_back</span>(s,startidx,i-startidx<span class="number">+1</span>);</span><br><span class="line">            <span class="built_in">traverse</span>(s,i<span class="number">+1</span>,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHuiwen</span><span class="params">(string &amp;s,<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start++]!=s[end--])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; path;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="built_in">traverse</span>(s,<span class="number">0</span>,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、39组合总和&lt;/h1&gt;
&lt;p&gt;给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。&lt;br&gt;
</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="组合" scheme="https://photin1a.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十八天|理论基础|77组合|216组合总和III|17电话号码的字母组合</title>
    <link href="https://photin1a.github.io/posts/ea0d66b9.html"/>
    <id>https://photin1a.github.io/posts/ea0d66b9.html</id>
    <published>2025-02-05T06:30:00.000Z</published>
    <updated>2025-02-05T10:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>理论基础</h1><ol><li>回溯是递归的副产品，只要有递归就会有回溯。<font color=red><strong>回溯函数也就是递归函数</strong></font>，指的都是一个函数。</li><li>回溯法并不是什么高效的算法。回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。</li><li>如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</li></ol><h2 id="既然回溯法并不高效为什么还要用它呢？">既然回溯法并不高效为什么还要用它呢？</h2><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><h2 id="回溯法解决的问题–-排列组合">回溯法解决的问题–&gt;排列组合</h2><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="框架模板">框架模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(路径，参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (nextnodes) &#123;</span><br><span class="line">        <span class="comment">//处理节点;</span></span><br><span class="line">        <span class="built_in">backtracking</span>(路径，参数); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1、77组合</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。</p><p><strong>我的思路</strong>：没做出来。。一开始我直接使用 <code>递归/回溯</code> 框架，但是结果有重复，如何去重？<br><img src="./ea0d66b9/permutation.jpg" alt=""><br><img src="./ea0d66b9/combinnation.jpg" alt=""><br><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：可以剪枝优化。对于递归的最后几个元素构不成组合。<br><img src="./ea0d66b9/jianzhi.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的排问题迭代框架</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;...)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j&lt;...)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">1</span>;k&lt;...)</span><br><span class="line">        i!=j j!=k</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的组合问题迭代框架，不走回头路</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;...)</span><br><span class="line">    <span class="keyword">for</span>(j = i<span class="number">+1</span>;j&lt;...)</span><br><span class="line">        <span class="keyword">for</span>(k = j<span class="number">+1</span>;k&lt;...)</span><br><span class="line"><span class="comment">//组合+剪枝</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;len-k ...)</span><br><span class="line">    <span class="keyword">for</span>(j = i<span class="number">+1</span>;j&lt;len-k<span class="number">+1</span> ...)</span><br><span class="line">        <span class="keyword">for</span>(k = j<span class="number">+1</span>;k&lt;len-k<span class="number">+2</span> ...)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span>(k = j;k&lt;len ...)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后我写的，未剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rec, <span class="type">int</span> dep,<span class="type">int</span> k, <span class="type">int</span> startidx, <span class="type">int</span> endidx, vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep == k)&#123; <span class="comment">//截止条件</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;=endidx-k+dep<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(rec[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(rec,dep<span class="number">+1</span>,k,i<span class="number">+1</span>,endidx,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        path.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="built_in">traverse</span>(rec,<span class="number">0</span>,k,<span class="number">0</span>,rec.<span class="built_in">size</span>()<span class="number">-1</span>,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rec, <span class="type">int</span> dep,<span class="type">int</span> k, <span class="type">int</span> startidx, <span class="type">int</span> endidx, vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep == k)&#123; <span class="comment">//截止条件</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;=endidx-k+dep<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(rec[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(rec,dep<span class="number">+1</span>,k,i<span class="number">+1</span>,endidx,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        path.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="built_in">traverse</span>(rec,<span class="number">0</span>,k,<span class="number">0</span>,rec.<span class="built_in">size</span>()<span class="number">-1</span>,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、216组合总和III</h1><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 最多使用一次<br>返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</li></ul><p><strong>我的思路：</strong> 和上一题一样。只需在截止条件处进行判断即可。<br><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rec, <span class="type">int</span> dep,<span class="type">int</span> k, <span class="type">int</span> startidx, <span class="type">int</span> endidx, vector&lt;<span class="type">int</span>&gt; &amp;path,<span class="type">int</span> sum, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep == k)&#123; <span class="comment">//截止条件</span></span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;=endidx-k+dep<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(rec[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(rec,dep<span class="number">+1</span>,k,i<span class="number">+1</span>,endidx,path,sum+rec[i],n,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        path.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="built_in">traverse</span>(rec,<span class="number">0</span>,k,<span class="number">0</span>,rec.<span class="built_in">size</span>()<span class="number">-1</span>,path,<span class="number">0</span>,n,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、17电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt=""></p><p><strong>我的思路</strong>：一开始还愣了一下，思路有点不清晰。这道题关键在于8个按键的字母是独立的，所以不用关心重复问题。<br><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><p><strong>小总结</strong>：遇到这种题有点模糊啊的话，就直接先用迭代for写出来框架，然后再用递归整理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(str[<span class="number">0</span>]的元素 )</span><br><span class="line">    <span class="keyword">for</span>(str[<span class="number">1</span>]的元素 )</span><br><span class="line">        <span class="keyword">for</span>(str[<span class="number">2</span>]的元素 )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;string&gt; &amp;res,string &amp;path,<span class="type">int</span> depth, string &amp;digits,unordered_map&lt;<span class="type">char</span>,string&gt; &amp;mem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = (digits[depth]==<span class="string">&#x27;7&#x27;</span>||digits[depth]==<span class="string">&#x27;9&#x27;</span>)?<span class="number">4</span>:<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            path+=mem[digits[depth]][i];</span><br><span class="line">            <span class="built_in">traverse</span>(res,path,depth<span class="number">+1</span>, digits,mem);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,string&gt; mem=&#123;&#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;abc&quot;</span>&#125;,&#123;<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>&#125;,&#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>&#125;,&#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>&#125;,&#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>&#125;,&#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">traverse</span>(res,path,<span class="number">0</span>, digits,mem);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">        string letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>();                       <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;理论基础&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;回溯是递归的副产品，只要有递归就会有回溯。&lt;font color=red&gt;&lt;strong&gt;回溯函数也就是递归函数&lt;/strong&gt;&lt;/font&gt;，指的都是一个函数。&lt;/li&gt;
&lt;li&gt;回溯法并不是什么高效的算法。回溯的本质是穷举，穷举</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="组合" scheme="https://photin1a.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十七天|669修剪二叉搜索树|108将有序数组转换为二叉搜索树|538把二叉搜索树转换为累加树|二叉树总结</title>
    <link href="https://photin1a.github.io/posts/9cf8583e.html"/>
    <id>https://photin1a.github.io/posts/9cf8583e.html</id>
    <published>2025-02-05T03:15:00.000Z</published>
    <updated>2025-02-05T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、669修剪二叉搜索树</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。<br><strong>我的思路</strong>： 使用构造二叉树的遍历框架。节点的左子树一定小于节点，所以如果这个节点值小于下界low则遍历右子树。节点的右子树一定大于节点，所以如果这个节点值大于上界high则遍历左子树。<br><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low)<span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;high)<span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、108将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵<br><strong>平衡二叉搜索树</strong>。<br><strong>平衡二叉搜索树</strong>：指该树所有节点的左右子树的高度相差不超过 1。</p><p><strong>我的思路</strong>：没做出来。<br><strong><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">代码随想录</a></strong>：以中间节点作为根节点构建的二叉树就是平衡二叉搜索树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解了之后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> index = (start+end)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(nums,start,index<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(nums,index<span class="number">+1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、538把二叉搜索树转换为累加树</h1><p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt=""><br><strong>我的思路</strong>：要保证所有元素大于或等于原来的值之和。只需要从右往左中序遍历累加即可。可以用构造二叉树的框架，也可以用遍历二叉树的框架。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;lastval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(root-&gt;right,lastval);</span><br><span class="line">        root-&gt;val += lastval; <span class="comment">//中</span></span><br><span class="line">        lastval = root-&gt;val;</span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(root-&gt;left,lastval);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> lastval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,lastval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123; <span class="comment">// 右中左遍历</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">        cur-&gt;val += pre;</span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录二叉树总结</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、669修剪二叉搜索树&lt;/h1&gt;
&lt;p&gt;给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十天|235二叉搜索树的最近公共祖先|701二叉搜索树中的插入操作|450删除二叉搜索树中的节点</title>
    <link href="https://photin1a.github.io/posts/722de76.html"/>
    <id>https://photin1a.github.io/posts/722de76.html</id>
    <published>2025-02-04T12:19:00.000Z</published>
    <updated>2025-02-05T03:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、235二叉搜索树的最近公共祖先</h1><p><strong>二叉搜索树特性</strong>：中序遍历是单调序列。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><blockquote><p>对于二叉搜索树，左树小于root，右树大于root。给定两个节点p和q，如果p小于root,q大于root，pq一定位于root的两边（两棵子树）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt;= root-&gt;val &amp;&amp; q-&gt;val &gt;= root-&gt;val)<span class="keyword">return</span> root;  <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt;= root-&gt;val &amp;&amp; q-&gt;val &lt;= root-&gt;val)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; p-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录，没写终止条件的情况。因为左右和终止条件是互补的，左右不满足返回cur就是终止条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="comment">// 左</span></span><br><span class="line">            TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="comment">// 右</span></span><br><span class="line">            TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、701二叉搜索树中的插入操作</h1><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><p><strong>我的思路：</strong> 一开始没想出来。看了代码随想录就会了。<br><img src="./722de76/insert.jpg" alt=""><br>这里提供两种思路，第一种在局部重构，第二种比较推荐，递归遍历找到空节点就加上。</p><p><strong>代码随想录</strong>：用的构造二叉树的那个框架。思路更清晰。推荐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看了代码随想录的思路后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">traverse</span>(root-&gt;left,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">traverse</span>(root-&gt;right,val);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);;</span><br><span class="line">        <span class="built_in">traverse</span>(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、450删除二叉搜索树中的节点</h1><p><strong>我的思路</strong>：没做出来。看了代码随想录后我写了，思路是先递归找到需要删除节点key的父节点，然后把key的1子树接上，2子树再递归接在1上。思路比较复杂。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt=""><br><strong><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：依然使用构造二叉树的框架去删除节点。整体逻辑清晰很多。<font color = red><strong>有一个关键点，由于右子树一定大于左子树，那么右子树一定接在左子树的右侧第一个nullptr上。反过来同理。</strong></font>这省去查找的麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入子树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse2</span><span class="params">(TreeNode* root,TreeNode* insert)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(insert == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(insert-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;left = insert;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;left,insert);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(insert-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;right = insert;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;right,insert);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = root-&gt;left-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;left = root-&gt;left-&gt;left;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;left,temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;left = root-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = root-&gt;right-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;right = root-&gt;right-&gt;left;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;right,temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;right = root-&gt;right-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)<span class="built_in">traverse</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)<span class="built_in">traverse</span>(root-&gt;right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;right,root-&gt;left);</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我写的递归构造框架--删除元素 同代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right!=<span class="literal">nullptr</span>)<span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;right!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 右子树接在左子树最右边</span></span><br><span class="line">                <span class="keyword">auto</span> temp = root-&gt;left; <span class="comment">//左子树</span></span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;right)temp = temp-&gt;right;</span><br><span class="line">                temp-&gt;right = root-&gt;right;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left; <span class="comment">//返回左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left,key);</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、235二叉搜索树的最近公共祖先&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树特性&lt;/strong&gt;：中序遍历是单调序列。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十八天|530二叉搜索树的最小绝对差|501二叉搜索树中的众数|236二叉树的最近公共祖先</title>
    <link href="https://photin1a.github.io/posts/6e8fafd0.html"/>
    <id>https://photin1a.github.io/posts/6e8fafd0.html</id>
    <published>2025-02-04T05:29:00.000Z</published>
    <updated>2025-02-04T12:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、530二叉搜索树的最小绝对差</h1><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值。差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>我的思路</strong>：先中序遍历得到二叉树的单调序列，然后检查每查询相邻两个之间的最小值。也可以不记录序列，只记录上一个差值就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;midseq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, midseq);</span><br><span class="line">        midseq.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, midseq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; midseq;</span><br><span class="line">        <span class="built_in">traverse</span>(root,midseq);</span><br><span class="line">        <span class="type">int</span> mindiff = std::<span class="built_in">abs</span>(midseq[<span class="number">1</span>]-midseq[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;midseq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> dif = std::<span class="built_in">abs</span>(midseq[i]-midseq[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dif &lt; mindiff)&#123;</span><br><span class="line">                mindiff = dif;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mindiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、501二叉搜索树中的众数</h1><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p><strong>我的思路</strong>：先用中序遍历得到一个递增序列，然后用双指针去序列里寻找频率最高的元素。其实我认为也可以直接当普通二叉树来处理，递归遍历存储节点出现频率再HashMap中，最后在map里寻找最大值。</p><p><strong><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：也是两种思路，首先通用二叉树遍历用HashMap存储，然后转为vector排序（map不能排序）。第二种他是直接在递归的过程中就计算频率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;midseq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, midseq);</span><br><span class="line">        midseq.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, midseq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; midseq;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pq;</span><br><span class="line">        <span class="built_in">traverse</span>(root,midseq);</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; midseq.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; midseq.<span class="built_in">size</span>() &amp;&amp; midseq[left]==midseq[right])&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((right-left) == maxnum)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(midseq[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((right-left) &gt; maxnum)&#123;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(midseq[left]);</span><br><span class="line">                maxnum = right-left;</span><br><span class="line">            &#125;</span><br><span class="line">           left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、236二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><code>百度百科</code>中<strong>最近公共祖先的定义为</strong>：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>我的思路</strong>：没做出来。之前我一直想如果p或q是子树根节点，那我返回之后岂不是无法遍历到另一个节点了。后面看了代码随想录后懂了，返回之后就不要遍历另一个节点了，因为这个返回节点就是root，已经找到了。<br><strong><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* leftre = <span class="built_in">traverse</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* righre = <span class="built_in">traverse</span>(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftre != <span class="literal">nullptr</span> &amp;&amp; righre != <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(leftre != <span class="literal">nullptr</span>)<span class="keyword">return</span> leftre;</span><br><span class="line">        <span class="keyword">if</span>(righre != <span class="literal">nullptr</span>)<span class="keyword">return</span> righre;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、530二叉搜索树的最小绝对差&lt;/h1&gt;
&lt;p&gt;给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值。差值是一个正数，其数值等于两值之差的绝对值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的思路&lt;/strong&gt;：先中序遍历得到二叉树的单调序列，然后</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十七天|654最大二叉树|617合并二叉树|700二叉搜索树中的搜索|98验证二叉搜索树</title>
    <link href="https://photin1a.github.io/posts/98db437f.html"/>
    <id>https://photin1a.github.io/posts/98db437f.html</id>
    <published>2025-02-02T14:50:00.000Z</published>
    <updated>2025-02-04T05:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、654最大二叉树</h1><p><strong>我的思路</strong>：和从<strong>前序、中序、后序重构二叉树</strong>的框架一样。应该重构二叉树都是一个框架。<br><a href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find max</span></span><br><span class="line">        <span class="type">int</span> maxval = nums[start];</span><br><span class="line">        <span class="type">int</span> idx = start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start<span class="number">+1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxval)&#123;</span><br><span class="line">                maxval = nums[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(maxval);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(nums,start,idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(nums,idx<span class="number">+1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、617合并二叉树</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt=""></p><p><strong>我的思路：</strong> 这道题还是递归的去构造二叉树就行，由于是两棵树所以参数是两个树节点。<br><strong><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 看了代码随想录之后发现我写的还是太冗余了。对于没有节点的位置我在树上虚拟了一个空节点。其实对于一个子树上没有节点的，直接把另一个树的子树接过来就ok。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root1-&gt;val +=root2-&gt;val;</span><br><span class="line">                root = root1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(root1 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root1-&gt;left,</span><br><span class="line">                                root2 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(root1 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root1-&gt;right,</span><br><span class="line">                                root2 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录之后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> )<span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span> )<span class="keyword">return</span> root1;</span><br><span class="line">        </span><br><span class="line">        root1-&gt;val +=root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、700二叉搜索树中的搜索</h1><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。<br><strong>二叉搜索树</strong>：也称二叉排序树或二叉查找树。<br>非空左子树的所有键值小于其根结点的键值。<br>非空右子树的所有键值大于其根结点的键值。<br>左、右子树都是二叉搜索树。<br><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt=""></p><p><strong>我的思路：</strong> 利用二叉搜索树的性质就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || val == root-&gt;val)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、98验证二叉搜索树</h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><blockquote><p>遇到二叉搜索树，一定想着<strong>中序遍历</strong>，这样才能利用上特性。二叉搜索树中不能有重复元素。</p></blockquote><p><strong>我的思路</strong>：没做出来。<br><strong><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 代码随想录也是利用这个性质。先中序遍历，再检查遍历结果是否单调。我的和它的区别是我没有保存全部遍历结果，我<strong>只保留最后一个元素，节省内存</strong>。</p><p><strong>二叉搜索树中序遍历特性：</strong> 中序遍历下，输出的二叉搜索树节点的数值是有序序列。验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 了解了 二叉搜索树中序遍历特性 后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root, TreeNode* &amp;lastnode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(root-&gt;left,lastnode) == <span class="literal">false</span>)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span>(lastnode != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= lastnode-&gt;val)&#123;  <span class="comment">//中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastnode = root;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(root-&gt;right,lastnode) == <span class="literal">false</span>)<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* lastnode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,lastnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、654最大二叉树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;我的思路&lt;/strong&gt;：和从&lt;strong&gt;前序、中序、后序重构二叉树&lt;/strong&gt;的框架一样。应该重构二叉树都是一个框架。&lt;br&gt;
&lt;a href=&quot;https://programmercarl.com/06</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十六天|513找树左下角的值|112路径总和|113路径综合II|106从中序与后序遍历序列构造二叉树|105从前序与中序遍历序列构造二叉树</title>
    <link href="https://photin1a.github.io/posts/28780bd.html"/>
    <id>https://photin1a.github.io/posts/28780bd.html</id>
    <published>2025-02-01T07:31:00.000Z</published>
    <updated>2025-02-02T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、513找树左下角的值</h1><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。<br><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt=""></p><p>我的思路：这道题<code>for循环</code>的层序遍历最好做。如果递归，就是要找到最大深度的第一个节点。<br><a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历，很简单</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        TreeNode* target = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> sz = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    target = node;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;maxDep,<span class="type">int</span> &amp;val, <span class="type">int</span> curDep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">// 截止条件</span></span><br><span class="line">            <span class="keyword">if</span>(curDep&gt;maxDep)&#123;</span><br><span class="line">                maxDep = curDep;</span><br><span class="line">                val = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;left,maxDep,val,curDep<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right,maxDep,val,curDep<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxDep = <span class="number">-1</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root,maxDep,val,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、112路径总和</h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 true ；否则，返回 false 。</p><p><strong>我的思路</strong>：递归解法。<br><strong>代码随想录</strong>：看了代码随想录后发现可以再继续优化，每次求累加实际上重复了，我们维护一个求和就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;TreeNode*&gt; &amp;path,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件-&gt;叶子节点</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node:path)&#123;</span><br><span class="line">                sum+=node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> sum == targetSum?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> le = <span class="literal">false</span>, ri = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            le = <span class="built_in">traverse</span>(root-&gt;left,path,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(le == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//遇到结果提前停止递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ri = <span class="built_in">traverse</span>(root-&gt;right,path,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(ri == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector&lt;TreeNode*&gt; path;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,path,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后的,,速度提升了很多</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> sum,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件-&gt;叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum == targetSum?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> le = <span class="literal">false</span>, ri = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            le = <span class="built_in">traverse</span>(root-&gt;left,sum+root-&gt;left-&gt;val,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(le == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ri = <span class="built_in">traverse</span>(root-&gt;right,sum+root-&gt;right-&gt;val,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(ri == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,root-&gt;val,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、113路径综合II</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。</p><p><strong>我的思路：</strong> 关键在于求路径那就需要记录路径，顺序路径意味着前序遍历。<br><strong>代码随想录：</strong> 一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;paths, vector&lt;<span class="type">int</span>&gt; &amp;path, <span class="type">int</span> sum,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件-&gt;叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum)&#123;</span><br><span class="line">                paths.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;left,paths,path,sum+root-&gt;left-&gt;val,targetSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right,paths,path,sum+root-&gt;right-&gt;val,targetSum);</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; paths;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">traverse</span>(root,paths,path,root-&gt;val,targetSum);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、106从中序与后序遍历序列构造二叉树</h1><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。<br><img src="https://labuladong.online/algo/images/binary-tree-ii/5.jpeg" alt=""><br><strong>我的思路：</strong> 没做出来。核心还是要熟二叉树的前中后遍历结果。<br><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/#%E9%80%9A%E8%BF%87%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><strong>labuladong</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看了labuladong后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> instart, <span class="type">int</span> inend, <span class="type">int</span> poststart, <span class="type">int</span> postend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart &gt; inend)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postend]);</span><br><span class="line">        <span class="type">int</span> rootidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rootidx = instart; rootidx&lt;= inend; rootidx++)&#123;   <span class="comment">// 可以用一个Hashmap查阅，增大效率。</span></span><br><span class="line">            <span class="keyword">if</span>(inorder[rootidx] == root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lftsize = rootidx - instart;</span><br><span class="line">        <span class="type">int</span> rgtsize = inend - rootidx;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(inorder,postorder,instart,rootidx<span class="number">-1</span>,poststart,poststart+lftsize<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(inorder,postorder,rootidx<span class="number">+1</span>,inend,poststart+lftsize,postend<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(inorder,postorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>5、105从前序与中序遍历序列构造二叉树</h1><p><img src="https://labuladong.online/algo/images/binary-tree-ii/1.jpeg" alt=""></p><p><strong>我的思路：</strong> 和106一样。核心还是要熟二叉树的前中后遍历结果。<br><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/#%E9%80%9A%E8%BF%87%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><strong>labuladong</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了labuladong后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; preorder, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> instart, <span class="type">int</span> inend, <span class="type">int</span> prestart, <span class="type">int</span> preend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart &gt; inend)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[prestart]);</span><br><span class="line">        <span class="type">int</span> rootidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rootidx = instart; rootidx&lt;= inend; rootidx++)&#123;   <span class="comment">// 可以用一个Hashmap查阅，增大效率。</span></span><br><span class="line">            <span class="keyword">if</span>(inorder[rootidx] == root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lftsize = rootidx - instart;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(inorder,preorder,instart,rootidx<span class="number">-1</span>,prestart<span class="number">+1</span>,prestart+lftsize);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(inorder,preorder,rootidx<span class="number">+1</span>,inend,prestart+lftsize<span class="number">+1</span>,preend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(inorder,preorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、513找树左下角的值&lt;/h1&gt;
&lt;p&gt;给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2020/12/14</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十五天|110平衡二叉树|257二叉树的所有路径|404左叶子之和|222完全二叉树的节点个数</title>
    <link href="https://photin1a.github.io/posts/57bd7082.html"/>
    <id>https://photin1a.github.io/posts/57bd7082.html</id>
    <published>2025-01-30T14:14:00.000Z</published>
    <updated>2025-02-01T07:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、110平衡二叉树</h1><p>给定一个二叉树，判断它是否是平衡二叉树。<br><strong>平衡二叉树</strong>：指该树所有节点的左右子树的高度相差不超过<code>1</code>。</p><p><strong>我的思路</strong>：这道题和最大深度不同，最大深度只需要递归返回最大深度，但是这里有两个信息需要返回，一个是返回节点高度来供父节点处理，二是当前节点不满足平衡就返回false。我把高度作为参数，返回值为是否平衡。<br><strong><a href="https://leetcode.cn/problems/balanced-binary-tree/">代码随想录</a></strong>：看了代码随想录，由于高度始终为正，所以可以把-1作为否平衡，&gt;0作为平衡。这样就只需要一个返回值，也就是当前节点的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root,<span class="type">int</span> &amp;hig)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            hig = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> higl = <span class="number">0</span>,higr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(root-&gt;left,higl) == <span class="literal">false</span> || </span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right,higr) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(std::<span class="built_in">abs</span>(higl-higr)&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hig = <span class="number">1</span>+std::<span class="built_in">max</span>(higl,higr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,hig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 判断-1就返回，不要等后序才返回，省时间</span></span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight); <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、257二叉树的所有路径</h1><p>给你一个二叉树的根节点 root ，按任意顺序 ，返回所有从根节点到叶子节点的路径。<br>叶子节点是指没有子节点的节点。</p><p><strong>我的思路：</strong> 我觉得这题的关键在于路径是从root指向叶子节点，也就是从上到下，所以可以使用前序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">// 中</span></span><br><span class="line">            string temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                temp+=std::<span class="built_in">to_string</span>(path[i])+<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp+=std::<span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//回溯</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left,path,res);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right,path,res);</span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">traverse</span>(root,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、404左叶子之和</h1><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>我的思路：</strong> 递归的第一要素就是找到截止条件，一般遍历判断当前节点是否为空指针即可，但是对于一些特殊情况，比如要求左叶子节点就必须找到父节点。<br><a href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> le = <span class="number">0</span>,ri = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件</span></span><br><span class="line">                le =  root-&gt;left-&gt;val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                le = <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ri = <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> le+ri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、222完全二叉树的节点个数</h1><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br><strong>完全二叉树定义</strong>：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ 2h 个节点。</p><p><strong>我的思路：</strong> 这道题第一眼看起来和求普通二叉树节点个数一样。选定返回值为当前节点以下的个数，则确定使用<strong>后序遍历</strong>。<br><strong><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 完全二叉树中大部分子树为满二叉树，对于满二叉树我们通过它的深度即可计算出节点个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通递归写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> le = <span class="built_in">countNodes</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> ri = <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+le+ri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截止条件：判断是不是满二叉树</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        <span class="type">int</span> leftdep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftdep++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> rightdep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightdep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftdep == rightdep)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftdep) - <span class="number">1</span>; <span class="comment">//注意(2&lt;&lt;1) 相当于2^2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left)+<span class="built_in">countNodes</span>(root-&gt;right); <span class="comment">//后序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、110平衡二叉树&lt;/h1&gt;
&lt;p&gt;给定一个二叉树，判断它是否是平衡二叉树。&lt;br&gt;
&lt;strong&gt;平衡二叉树&lt;/strong&gt;：指该树所有节点的左右子树的高度相差不超过&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的思路&lt;/strong&gt;：这道题和</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十四天|226翻转二叉树(递归)|101对称二叉树(递归)|104二叉树的最大深度(递归)|111二叉树的最小深度(递归)</title>
    <link href="https://photin1a.github.io/posts/553b0985.html"/>
    <id>https://photin1a.github.io/posts/553b0985.html</id>
    <published>2025-01-26T14:27:00.000Z</published>
    <updated>2025-01-30T14:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、226翻转二叉树</h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt=""><br><strong>我的思路：</strong> 懵了一会儿。遍历到当前节点时，需要将它的子节点交换一下。所以需要在<strong>前序位置</strong>做交换最合适。<br><strong><a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：递归遍历、DFS迭代遍历（栈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的递归遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录，DFS深度优先，迭代遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、101对称二叉树</h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>我的思路：</strong> 把树分为左子树和右子树，两棵树同时遍历比较。左子树从左到右，右子树从右到左。可以共用一个队列。我只想到层序遍历。<strong><font color='red'> 递归想不出来。两个子树同时递归怎么做？</font></strong><br><strong><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></strong>：看了代码随想录之后我发现好简单，<strong>递归函数参数多传一个节点就行。。</strong> <font color='gree'>我觉得难点在于如何判断使用哪种递归方式（前、中、后），以及递归返回值、递归参数怎样确定。</font><br><a href="https://www.bilibili.com/video/BV1ue4y1Y7Mf/?vd_source=d83fadd3138d002993b778881de0f2e9"><strong>视频</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(root-&gt;left); <span class="comment">//left tree</span></span><br><span class="line">        pq.<span class="built_in">push</span>(root-&gt;right); <span class="comment">//right tree</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> left = pq.<span class="built_in">front</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> right = pq.<span class="built_in">front</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right!=<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            pq.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            pq.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            pq.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后我写的递归解法</span></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* tl,TreeNode* tr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="literal">nullptr</span> &amp;&amp; tr!=<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//终止递归的条件</span></span><br><span class="line">        <span class="keyword">if</span>(tl != <span class="literal">nullptr</span> &amp;&amp; tr==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="literal">nullptr</span> &amp;&amp; tr==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(tl-&gt;val != tr-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> out = <span class="built_in">traverse</span>(tl-&gt;left,tr-&gt;right);</span><br><span class="line">        <span class="type">bool</span> in = <span class="built_in">traverse</span>(tl-&gt;right,tr-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> out &amp;&amp; in;  <span class="comment">// 后序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、104二叉树的最大深度（递归解法）</h1><p><strong>我的思路：</strong> 这道题用递归解法来解。我把depth和max_depth作为递归函数参数。<strong><font color = red>我感觉我对递归函数返回值怎样设计一窍不通，导致很多变量我都放在参数里，没有返回值就意味着基本都是前序遍历。</font></strong></p><blockquote><p><strong>我的小思考</strong>：前序就是从上往下递归，后序就是从下往上收拢，所以后序一般用于返回值</p></blockquote><p><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：</p><ol><li><strong>确定递归函数的参数和返回值</strong>：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li><li><strong>确定终止条件</strong>：如果为空节点的话，就返回0，表示高度为0。</li><li><strong>确定单层递归的逻辑</strong>：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的递归解法，本质上还是前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, <span class="type">int</span> &amp;max_depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max_depth)&#123;  </span><br><span class="line">            max_depth = depth;  <span class="comment">// 中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left,depth<span class="number">+1</span>,max_depth); <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right,depth<span class="number">+1</span>,max_depth); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root,depth,max_depth);</span><br><span class="line">        <span class="keyword">return</span> max_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录递归解法，属于后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left_depth = <span class="built_in">traverse</span>(root-&gt;left); <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> right_depth = <span class="built_in">traverse</span>(root-&gt;right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+std::<span class="built_in">max</span>(left_depth,right_depth); <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、111二叉树的最小深度（递归解法）</h1><p><strong>我的思路：</strong> 受上一题的启发 --&gt; 递归最终的结果作为返回值，主要是找到截止条件。二叉树的遍历一般是判断当前指针是否为nullptr截止，但是最小深度需要判断子节点的全部是否为nullptr。</p><p><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：和我的思路一样，写的没我的绕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的递归解法 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left_depth = <span class="number">9999999</span>;</span><br><span class="line">        <span class="type">int</span> right_depth = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            left_depth = <span class="built_in">traverse</span>(root-&gt;left); <span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right_depth = <span class="built_in">traverse</span>(root-&gt;right); <span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+std::<span class="built_in">min</span>(left_depth,right_depth); <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、226翻转二叉树&lt;/h1&gt;
&lt;p&gt;给你一棵二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，翻转这棵二叉树，并返回其根节点。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2021/03/14/invert1-</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十三天|理论基础|二叉树的递归遍历（前、中、后）|二叉树的迭代遍历|二叉树的层序遍历</title>
    <link href="https://photin1a.github.io/posts/76e5d8f8.html"/>
    <id>https://photin1a.github.io/posts/76e5d8f8.html</id>
    <published>2025-01-24T04:04:00.000Z</published>
    <updated>2025-01-26T14:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>理论基础</h1><p><strong>二叉树的种类：</strong></p><ul><li>满二叉树：二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上</li><li>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。（例如大顶堆和小顶堆就是这种数据结构）</li><li>二叉搜索树：二叉搜索树是一个有序树，左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。</li><li>平衡二叉树：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn。</strong></li></ul><h2 id="遍历框架">遍历框架</h2><h3 id="递归遍历（DFS）">递归遍历（DFS）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""></h3><h1>1、144二叉树的前序遍历、145二叉树的后序遍历、94二叉树的中序遍历</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2、二叉树的迭代遍历</h1><p>先放过</p><h1>3、二叉树的统一迭代法</h1><p>先放过</p><h1>4、二叉树的层序遍历</h1><p><strong><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">labuladong框架</a>：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// *****条件***** //</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、for循环记录层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="comment">// *****条件***** //</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-102二叉树的层序遍历">4.1 102二叉树的层序遍历</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br><strong>直接套框架:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res_t</span><span class="params">(num)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="type">res_t</span>[i] = cur-&gt;val;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="type">res_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-107二叉树的层序遍历II">4.2 107二叉树的层序遍历II</h2><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>我的思路：</strong> 比较容易想到的方法就是<strong>正常层序遍历</strong>然后最后<code>reverse</code>一下就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="4-3-199二叉树的右视图">4.3 199二叉树的右视图</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>我的思路：</strong> 和就是层序遍历，只不过每一层只要一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-637二叉树的层平均值">4.4 637二叉树的层平均值</h2><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><p><strong>我的思路：</strong> 还是带for循环版本的层序遍历。最后发现有一个案例，全是<code>int最小值</code>过不了。<code>64 / 66 个通过的测试用例。</code> 我用<code>int sum</code>去求和提示溢出，于是我把每个元素除以<code>size</code>先求平均值再相加。这样应该会损失精度。后面改为<code>long long sum</code>就可以了。测试<code>double sum</code>也可以。<code>double</code> 类型可以表示大约 <code>15-17</code> 位有效数字，用来表示整数<code>(10位左右)</code>足够了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 案例</span></span><br><span class="line">-2147483336-2147483647-2147483646-2147483647-2147483647-2147483647-2147483644-2147483647-2147483647-2147483525-2147483647-2147483647-2147483646-2147483646-2147483646 ...</span><br><span class="line"><span class="comment"># 我的输出</span></span><br><span class="line">[0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,-0.00002]</span><br><span class="line"><span class="comment"># 正确输出</span></span><br><span class="line">[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> ave = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val!=<span class="number">0</span>)&#123;</span><br><span class="line">                    ave+=<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(cur-&gt;val)/num;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(ave);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了代码随想录后的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                sum+=cur-&gt;val;</span><br><span class="line">                </span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(sum/num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-5-429N叉树的层序遍历">4.5 429N叉树的层序遍历</h2><p><strong>我的思路：</strong> 简单，就是二叉树的拓展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(); </span><br><span class="line">        queue&lt;Node*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res_t</span><span class="params">(num)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="type">res_t</span>[i] = cur-&gt;val;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="type">node_t</span>:cur-&gt;children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="type">node_t</span>!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                        pq.<span class="built_in">push</span>(<span class="type">node_t</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="type">res_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-6-515在每个树行中找最大值">4.6 515在每个树行中找最大值</h2><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p><strong>我的思路：</strong> 层序遍历框架。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> max = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val &gt; max)&#123;</span><br><span class="line">                    max = cur-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-7-116填充每个节点的下一个右侧节点指针">4.7 116填充每个节点的下一个右侧节点指针</h2><p>给定一个 <strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt=""><br><strong>我的思路：</strong> 层序遍历。只是应该存储上一次的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的，代码不是很漂亮，思路是对的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root; </span><br><span class="line">        queue&lt;Node*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> last = pq.<span class="built_in">front</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(last-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(last-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(last-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(last-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                last-&gt;next = cur;</span><br><span class="line">                last = cur;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// vector&lt;int&gt; vec;</span></span><br><span class="line">            Node* nodePre;</span><br><span class="line">            Node* node;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>(); <span class="comment">// 取出一层的头结点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node; <span class="comment">// 本层前一个节点next指向本节点</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-8-117填充每个节点的下一个右侧节点指针II">4.8 117填充每个节点的下一个右侧节点指针II</h2><p>Same to <code>4.7 116填充每个节点的下一个右侧节点指针</code></p><h2 id="4-9-104二叉树的最大深度">4.9 104二叉树的最大深度</h2><p>给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>我的思路：</strong> 层序遍历。每层计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-10">4.10</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。</p><p><strong>我的思路：</strong> 层序遍历。和最大深度区别是找到一个叶子节点就停。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span> &amp;&amp; cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> depth<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;理论基础&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉树的种类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满二叉树：二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上&lt;/li&gt;
&lt;li&gt;完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十一天|150逆波兰表达式求值|239滑动窗口最大值|347前K个高频元素</title>
    <link href="https://photin1a.github.io/posts/780df565.html"/>
    <id>https://photin1a.github.io/posts/780df565.html</id>
    <published>2025-01-18T07:04:00.000Z</published>
    <updated>2025-01-18T07:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、150逆波兰表达式求值</h1><p><strong>我的思路：</strong> 看了代码随想录才做的。就觉得比较简单。<br><strong><a href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; com;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;tokens.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a*b);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a/b);</span><br><span class="line">            &#125;     </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a+b);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a-b);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                com.<span class="built_in">push</span>(std::<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> com.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、239滑动窗口最大值</h1><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p><p><strong>我的思路：</strong> 没做出来。首先最直接能想到的是对每个滑动窗口都求一遍最大值，这样是挺简单的。但是，我们在滑动窗口的时候其实后面的窗口和前面的窗口是重叠的，如果对每个滑动窗口都求一遍最大值无疑是有很多重复计算。其实前面窗口排好序之后，后面的窗口也只需比较最后一个元素就能排序，再退一步，我们其实我们除了需要知道窗口里的元素，额外只要知道第二大的的元素就行，下一个窗口只要和第二大的元素或最大的元素比较就可以。<br><strong><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录</a>：</strong> 单调队列。单调队列维护所有具有单调性的元素。不更改元素的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录之后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>,left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right = <span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= k &amp;&amp; nums[right-k]==dq.<span class="built_in">front</span>())&#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[right]&gt;dq.<span class="built_in">back</span>())&#123;</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dq.<span class="built_in">emplace_back</span>(nums[right]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= k<span class="number">-1</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(dq.<span class="built_in">front</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123; <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、347前K个高频元素</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按任意顺序返回答案。</p><p><strong>我的思路：</strong> 很容易想到的思路，用一个map存储元素出现次数，最后对map排序一遍。如果使用<code>unordered_map</code>则不支持排序需要重新拷贝到<code>vector</code>里。<br><strong><a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>：</strong> 同样使用<code>map</code>去记录元素的频率，然后用一个<code>优先级队列（小顶堆）</code>去排序，优先级队列维持k的大小，这样排序只需要对k个元素排序。</p><pre><code class="language-cpp">class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        auto cmp = [](pair&lt;int,int&gt; &amp;last,pair&lt;int,int&gt; &amp;cur)&#123;            return last.second &gt; cur.second;        &#125;;        unordered_map&lt;int,int&gt; mp;        for(int i = 0;i&lt;nums.size();i++)&#123;            mp[nums[i]]++;        &#125;        std::vector&lt;std::pair&lt;int, int&gt;&gt; vec(mp.begin(), mp.end());        std::sort(vec.begin(),vec.end(),cmp); // 排序nlogn复杂度（以快排为例）        vector&lt;int&gt; res;                int i = 0;        for(auto &amp;it:vec)&#123;            if(i++&gt;=k)break;            res.emplace_back(it.first);        &#125;        return res;    &#125;&#125;;// 看了代码随想录后写的class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        auto cmp = [](pair&lt;int,int&gt; &amp;newit,pair&lt;int,int&gt; &amp;oldit)&#123;            return newit.second &gt; oldit.second;        &#125;;        unordered_map&lt;int,int&gt; mp;        for(int i = 0;i&lt;nums.size();i++)&#123;            mp[nums[i]]++;        &#125;        priority_queue&lt;pair&lt;int,int&gt;,deque&lt;pair&lt;int,int&gt;&gt;,decltype(cmp)&gt; pq(cmp);        int i=1;        for(auto &amp;it:mp)&#123;  // 维持pq的尺寸为k，那么每次排序logk复杂度，总的O(nlogk)（以快排为例）            if(i&gt;k)&#123;                if(it.second &gt; pq.top().second)&#123;                   pq.emplace(it);                    pq.pop();                &#125;            &#125;else&#123;                pq.emplace(it);            &#125;            i++;        &#125;        vector&lt;int&gt; res(pq.size());        for(int j = res.size()-1;j&gt;=0;j--)&#123;            res[j] = pq.top().first;            pq.pop();        &#125;        return res;    &#125;&#125;;``</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、150逆波兰表达式求值&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;我的思路：&lt;/strong&gt; 看了代码随想录才做的。就觉得比较简单。&lt;br&gt;
&lt;strong&gt;&lt;a href=&quot;https://programmercarl.com/0150.%E9%80%86%E6%B3%A2</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="栈与队列" scheme="https://photin1a.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十天|232用栈实现队列|225用队列实现栈|20有效的括号|1047删除字符串中的所有相邻重复项</title>
    <link href="https://photin1a.github.io/posts/6bc5198a.html"/>
    <id>https://photin1a.github.io/posts/6bc5198a.html</id>
    <published>2025-01-17T06:09:00.000Z</published>
    <updated>2025-01-17T06:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>栈与队列理论基础</h1><p><strong>栈和队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的</strong>（底层容器可替换）。<br>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><p>我们常用的<code>SGI STL</code>（gcc所使用的stl库）默认是以<code>deque</code>为缺省情况下栈的底层结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>&gt; third; <span class="comment">// 默认deque</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><h1>1、232用栈实现队列</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 true ；否则，返回 false</li></ul><p><strong>我的思路：</strong> 好吧。没做出来。<br><strong><a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 用两个栈一个进另一个再转进去弹出。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; out;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> top = <span class="built_in">peek</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                out.<span class="built_in">push</span>(in.<span class="built_in">top</span>());</span><br><span class="line">                in.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>()&amp;&amp;out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、225用队列实现栈</h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p><strong>我的思路：</strong> 还是没做出来。。<br><strong><a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 使用一个队列就可以完成。一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、20有效的括号</h1><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li><li></li></ul><p><strong>我的思路：</strong> 这道题比较简单，依次符号入栈，然后下一个符号如果能和栈顶匹配就消去，和消消乐一样。<strong><font color='red'>但是问题是–要不是这节课学的就是栈，我可能想不到用栈去做。笔试时怎么办？</font></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、1047删除字符串中的所有相邻重复项</h1><p>给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><ul><li>输入：“abbaca”</li><li>输出：“ca”</li></ul><p><strong>我的思路：</strong> 和上一题<code>20有效的括号</code>一样，也是找到同类元素消除。开心消消乐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==s[i])&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res+=sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;栈与队列理论基础&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;栈和队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的&lt;/strong&gt;（底层容器可替换）。&lt;br&gt;
所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。&lt;/</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="栈与队列" scheme="https://photin1a.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第九天|151翻转字符串里的单词|卡码网-55右旋转字符串|28实现strStr()|459重复的子字符串</title>
    <link href="https://photin1a.github.io/posts/5a27cff6.html"/>
    <id>https://photin1a.github.io/posts/5a27cff6.html</id>
    <published>2025-01-16T06:00:00.000Z</published>
    <updated>2025-01-16T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、151翻转字符串里的单词</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p><strong>我的思路：</strong> 首先这道题返回一个新串，不要求在原串上修改，所以简便很多。直接一个每个区域用双指针填充就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的。。比较水的解法。。。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> low = s.<span class="built_in">size</span>()<span class="number">-1</span>,fast = low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(fast&gt;=<span class="number">0</span> &amp;&amp; s[fast]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                fast--;</span><br><span class="line">            &#125;;</span><br><span class="line">            low = fast;</span><br><span class="line">            <span class="keyword">while</span>(fast&gt;=<span class="number">0</span> &amp;&amp; s[fast]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                fast--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">append</span>(s,fast<span class="number">+1</span>,low-fast);</span><br><span class="line">            res+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">back</span>()==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">代码随想录</a>：</strong> <strong>分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</strong></p><h2 id="提升：不要使用辅助空间，空间复杂度要求为O-1-。">提升：不要使用辅助空间，空间复杂度要求为O(1)。</h2><p>方法： &quot;the sky is blue &quot;</p><ul><li>移除多余空格：<code>&quot;the sky is blue&quot;</code> 对应<code>27移除元素</code></li><li>字符串反转：<code>&quot;eulb si yks eht&quot;</code>对应<code>344反转字符串</code></li><li>单词反转：<code>&quot;blue is sky the&quot;</code>对应<code>541反转字符串II</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后我写的</span></span><br><span class="line"><span class="comment">// 可以直接当模板拿来写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// remove extra /0x20  移除连续重复的元素</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(fast = <span class="number">0</span>;fast &lt; s.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fast]==<span class="string">&#x27; &#x27;</span> &amp;&amp; (fast==<span class="number">0</span> || s[fast<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>))<span class="keyword">continue</span>;</span><br><span class="line">            s[low++] = s[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> length = s[low<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>?low<span class="number">-1</span>:low;  <span class="comment">//最后可能有空格，长度需要-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// str reverse   // 字符串逆序</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = s[right];</span><br><span class="line">            s[right] = s[left];</span><br><span class="line">            s[left] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word reverse   //单词逆序</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &lt; length)&#123;</span><br><span class="line">            left = p;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; length &amp;&amp; s[p]!= <span class="string">&#x27; &#x27;</span>)p++;</span><br><span class="line">            right = p<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = s[right];</span><br><span class="line">                s[right] = s[left];</span><br><span class="line">                s[left] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s,<span class="number">0</span>,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、卡码网-55右旋转字符串</h1><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。<br>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p><p><strong>我的思路：</strong> 受前面一题<code>151翻转字符串里的单词</code> 的启发，可以先反转整个串，然后把对应的需要的部分反转。</p><p><strong>tips：</strong> 反转字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;str, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = start, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = str[right];</span><br><span class="line">        str[right] = str[left];</span><br><span class="line">        str[left] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rota</span><span class="params">(string &amp;str,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// reverse 所有字符</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(str,left,right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reverse 前k个字符</span></span><br><span class="line">    left = <span class="number">0</span>,right = k<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(str,left,right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reverse 剩下字符</span></span><br><span class="line">    left = k,right = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(str,left,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; str;</span><br><span class="line">    <span class="built_in">rota</span>(str,k);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3、28实现strStr()</h1><blockquote><p>二刷再做</p></blockquote><h1>4、459重复的子字符串</h1><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>我的思路：</strong> 使用for循环一个一个的匹配。看着简单，写起来还是有点发愣的，也用了30来分钟。O(n^2)复杂度。</p><p><strong><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录-移动匹配法</a>：</strong> 如果s是一个重复子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的暴力解法，leetcode通过了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()%i!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = l+i;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l]==s[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span>(l &gt;= i)&#123;</span><br><span class="line">                    l=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r == s.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = s + s;</span><br><span class="line">        t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>()); t.<span class="built_in">erase</span>(t.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">find</span>(s) != std::string::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// find调用库函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、151翻转字符串里的单词&lt;/h1&gt;
&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。&lt;br&gt;
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第八天|344反转字符串|541反转字符串II|卡码网-54替换数字</title>
    <link href="https://photin1a.github.io/posts/f6a04131.html"/>
    <id>https://photin1a.github.io/posts/f6a04131.html</id>
    <published>2025-01-15T08:45:00.000Z</published>
    <updated>2025-01-15T08:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、344反转字符串</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><ul><li>左右双指针</li></ul><p><strong>我的思路：</strong> 这道题很常规的问题，直接左右双指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = s[right];</span><br><span class="line">            s[right] = s[left];</span><br><span class="line">            s[left] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、541反转字符串II</h1><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><ul><li>如果剩余字符少于 k 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</li></ul><p><strong>我的思路：</strong> 这道题和上一道题类似，都是反转字符串，只是这道题是分区域反转。直接使用左右双指针一个一个区域的反转就行。</p><p><strong>代码随想录：</strong> 直接用了for循环，非主要考察的部分可以直接用库函数，例如<code>reverse</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            right = right &lt; s.<span class="built_in">size</span>()?right:s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> i =left,j = right;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = s[j];</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">                s[i] = temp;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left = left<span class="number">+2</span>*k;</span><br><span class="line">            right = left+k<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、卡码网-54替换数字</h1><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p><strong>我的思路：</strong> 我想的就是很简简单方法，直接依次遍历，遇到数字就换成<code>number</code>，结果用一个新字符串存储。<br><strong>代码随想录：</strong> 做到极致，不申请多余的临时变量。如果不申请临时的空间在原来的上面修改时会覆盖那些还没有遍历过的字符，<strong>核心还是解决覆盖问题。</strong> 在<code>88合并两个有序数组</code>中遇到过类似的做法，从后往前排就可以避免覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transNum</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=str[i]&amp;&amp; str[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            temp+=<span class="string">&quot;number&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp+=str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str = std::<span class="built_in">move</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    std::cin &gt;&gt; str;</span><br><span class="line">    <span class="built_in">transNum</span>(str);</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="type">int</span> sOldIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> sNewIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从后往前将数字替换为&quot;number&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (sOldIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[sOldIndex] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[sNewIndex--] = s[sOldIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            sOldIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、344反转字符串&lt;/h1&gt;
&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。&lt;br&gt;
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左右双指针&lt;/l</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第七天|454四数相加II|383赎金信|15三数之和|18四数之和</title>
    <link href="https://photin1a.github.io/posts/3d015e1d.html"/>
    <id>https://photin1a.github.io/posts/3d015e1d.html</id>
    <published>2025-01-14T07:18:00.000Z</published>
    <updated>2025-01-15T14:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>tips：</strong> unordered_map用来存储数组（val，index）可以快速找到目标值的索引。</p><h1>1、454四数相加II</h1><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><ul><li>0 &lt;= i, j, k, l &lt; n</li><li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li></ul><p><strong>我的思路：</strong> 一开始我想的类似动态规划的思路一样，把从下往上一层一层的计算求和和数量，用HashMap存储，最后直接find查找，这样复杂度有点大。<br><strong>代码随想录：</strong> 他把上两行遍历求和统计在map中，下两行也遍历，遍历途中就直接find上两行的map里有没有合适的。而我是全部求出来。<code>1两数之和</code>也是类似思路。</p><ul><li><strong>多层迭代分解成多个子问题</strong>，这样比全部一起迭代快，全部一起迭代是n^4，但是分解为上下两部分时2*n^2。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mapi,mapj,mapk,mapl; <span class="comment">//val idx</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mapl[nums4[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l:mapl)&#123;</span><br><span class="line">                mapk[nums3[i]+l.first]+=l.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k:mapk)&#123;</span><br><span class="line">                mapj[nums2[i]+k.first]+=k.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ii:mapj)&#123;</span><br><span class="line">                mapi[nums1[i]+ii.first]+=ii.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapi[<span class="number">0</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map; <span class="comment">//val idx</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            map[nums1[i]+nums2[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(-nums3[i]-nums4[j]);</span><br><span class="line">            <span class="keyword">if</span>(it!=map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                len+=it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、383赎金信</h1><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p><strong>我的思路：</strong> ：这道题之前遇到过类似的<code>242有效的字母异位词</code>，按照我常规的思路就是直接两个数组都用Hashmap把元素和出现的次数存起来，然后两个map作比较看看他们的数量是否均等。但是在<code>代码随想录-242有效的字母异位词</code>学到了新思路，就是统计字符串1在map中，然后遍历字符串2，每遍历一次对应的map中的对应字符的数量-1，最后map中全为0则符合题意。<br><strong>代码随想录：</strong> ：和我说的方法一样。与之不同的是，他用一个数组来代替HashMap，因为<strong>题目说字符都是小写英文，所以是有限的，用数组足够</strong>，注意看题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; ran,mag;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;ransomNote.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ran[ransomNote[i]]++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;magazine.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ran[magazine[i]]!=<span class="number">0</span>)&#123;</span><br><span class="line">                ran[magazine[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:ran)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 通过record数据记录 magazine里各个字符出现次数</span></span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span></span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span></span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、15三数之和</h1><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p><p><strong>常用Tips：</strong> 把数组先排序，再处理。</p><p><strong>我的思路：</strong> 这道题耗费很长时间没做出来。这道题应该是<code>1两数之和</code>的加强版，首先都是在一个数组上寻找两个或多个值之和等于target的元素。我的思考是需要保证搜索时多个数的索引不能出现交叉，比如i=10，那就要一只在0~i之间，k就要在0~j之间。不然就会出现重复搜索，加慢速度。</p><ul><li><strong>怎么保证搜索过三个元素值的不在重复？</strong><br><strong>我的思考：</strong> 三个数不能出现重复的，比如{1,2,5}和{5,2,1}就重复了。<strong>问题是有没有什么机制找出他们的共性？？<strong>晕了一下我脑子里出现了一些操作，比如</strong>排序之后它两每个元素就都相同</strong>，不知道是什么时候刷题刷出这个感觉。但是如果用<code>HashMap</code>的话，这是三个元素没法放在键值里，必须自己重写Hash函数。于是由于我之前看<code>Apollo</code>的代码在写<code>A*</code>算法时用到了将<strong>下标转为字符串</strong>的做法，我也就萌生了这个想法。</li></ul><p><strong>我写的：</strong>  只通过了309/313个数据，其他的超时。可能是使用string做Hash键的原因。</p><p><strong><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>：</strong> 两层for循环就可以确定 两个数值，可以使用哈希法来确定 第三个数 0-(a+b) 或者 0 - (a + c) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。其他思路比较好的思路是先<strong>排序，再双指针搜索</strong>。</p><p><strong>思考：</strong> 在<code>1两数之和</code>中用了一层for循环，第二个数用HashMap确定，这道题我一开始想其他的牛b方法，硬是想不到。最后我还是前两个数用for循环，最后一个数用HashMap。但是看了代码随想录之后有了些反思：<strong><font color='red'>很多时候解题并不需要什么NB的方法，只是我过分追求于完美导致了最后首尾难顾，时间也过去了。谨记：追求完美，面面俱到，很难成功！！</font></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; maps;</span><br><span class="line">        std::unordered_set&lt;string&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = maps.<span class="built_in">find</span>(-nums[i]-nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(it!=maps.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k:it-&gt;second)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(k&lt;j)&#123;</span><br><span class="line">                            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(&#123;nums[i],nums[j],nums[k]&#125;)</span></span>;</span><br><span class="line">                            <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">                            <span class="keyword">auto</span> str = <span class="built_in">to_string</span>(temp[<span class="number">0</span>])+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(temp[<span class="number">1</span>])+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(temp[<span class="number">2</span>]);</span><br><span class="line">                            <span class="keyword">if</span>(res.<span class="built_in">find</span>(str)==res.<span class="built_in">end</span>())&#123;</span><br><span class="line">                                re.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[j],nums[k]&#125;));</span><br><span class="line">                            &#125;</span><br><span class="line">                            res.<span class="built_in">emplace</span>(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了代码随想录的视频后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            left = i<span class="number">+1</span>;</span><br><span class="line">            right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">continue</span>; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;  <span class="comment">//剪枝</span></span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left!=i<span class="number">+1</span> &amp;&amp; nums[left]==nums[left<span class="number">-1</span>])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  <span class="comment">//剪枝</span></span><br><span class="line">                <span class="keyword">if</span>(right!=nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[right]==nums[right<span class="number">+1</span>])&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  <span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[left]+nums[right]-target==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[left],nums[right]&#125;));</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]-target&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]-target&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leetcode 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、18四数之和</h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p><strong>我的思路：</strong> 这道题三数之和的进阶版。我的思路是前两个数嵌套for循环，后两个数用双指针。<br><strong>遇到的几个坑，折腾了好久：</strong></p><ul><li><code>for(int i = 0;i&lt; nums.size()-3;i++)</code>这句代码中num.size()返回的是size_t(long unsigned int)无符号类型，所以-3之后如果是负数会转换为极大的正数。一直循环。。正确的做法<code>for(int i = 0;i&lt; (int)nums.size()-3;i++)</code>。</li><li><code>if(nums[i]&gt;target)continue;</code> 剪枝只有在<code>target=0</code>时才有效。替换为<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code></li></ul><p><strong><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// if(nums[i]&gt;target)continue; //剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;  <span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>;j&lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>()<span class="number">-2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i<span class="number">+1</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>])<span class="keyword">continue</span>;  <span class="comment">//剪枝</span></span><br><span class="line">                left = j<span class="number">+1</span>;</span><br><span class="line">                right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="type">long</span> target1 = (<span class="type">long</span>)target-nums[i]-nums[j];</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(left!=j<span class="number">+1</span> &amp;&amp; nums[left]==nums[left<span class="number">-1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;  <span class="comment">//剪枝</span></span><br><span class="line">                    <span class="keyword">if</span>(right!=nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[right]==nums[right<span class="number">+1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;  <span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(nums[left]+nums[right]==target1)&#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[j],nums[left],nums[right]&#125;));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[left]+nums[right]-target1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[left]+nums[right]-target1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt; unordered_map用来存储数组（val，index）可以快速找到目标值的索引。&lt;/p&gt;
&lt;h1&gt;1、454四数相加II&lt;/h1&gt;
&lt;p&gt;给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第六天|哈希表理论基础|242有效的字母异位词|349两个数组的交集|202快乐数|1两数之和</title>
    <link href="https://photin1a.github.io/posts/5f4e67ee.html"/>
    <id>https://photin1a.github.io/posts/5f4e67ee.html</id>
    <published>2025-01-13T07:15:00.000Z</published>
    <updated>2025-01-13T07:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>哈希表理论基础</h1><h2 id="什么时候用哈希法？">什么时候用哈希法？</h2><p>当我们遇到了要<strong>快速判断一个元素是否出现集合里</strong>的时候，就要考虑哈希法。</p><h2 id="Hash表">Hash表</h2><p>数组就是一张哈希表。我们通过Hash函数把<code>键</code>映射成一个整数值，然后通过取模操作映射到哈希表的索引上。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt=""><br>但是可能出现多个键都映射到同一个索引上，这个现象叫<strong>哈希碰撞</strong>。解决这个问题有两个方案，一个是<strong>拉链法</strong>，一个是<strong>线性探测法</strong>。</p><table>  <tr>    <td><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png" alt="拉链法" width="100%" height="200"></td>    <td><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png" alt="线性探测法" width="100%" height="200"></td>  </tr></table><h2 id="常见的三种Hash结构">常见的三种Hash结构</h2><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>数组就没啥可说的了。在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p><code>std::unordered_set</code>底层实现为哈希表，<code>std::set</code> 和<code>std::multiset</code> 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th>映射</th><th>实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p><code>std::unordered_map</code> 底层实现为哈希表，<code>std::map</code> 和<code>std::multimap</code> 的底层实现是红黑树。同理，<code>std::map</code> 和<code>std::multimap</code> 的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><h1>1、242有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br><strong>我的思路：</strong> 异位词指的就是两个字符串中每个字符出现的次数是相同的。我可以用两个unordered_map统计他们出现的次数，然后比较是否相等。</p><p><strong><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 这里比较巧妙，他只用一个map去存第一个字符串的元素出现次数。然后去第二个字符串上去遍历，每统计到一个元素就-1，这样如果map所有值都为0就说明两个字符串是异位词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=t.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map1,map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            map1[s[i]]++;</span><br><span class="line">            map2[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]]!=map2[s[i]])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、349两个数组的交集</h1><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集。输出结果中的每个元素一定是唯一 的。我们可以 不考虑输出结果的顺序 。</p><blockquote><p><strong>tips:</strong> 不涉及到排序问题就用<code>Hash容器</code>。这里关键在于只用统计元素是否出现，不用统计他们出现的次数。所以使用<code>unordered_set</code>更好，若是涉及次数的使用<code>unordered_map</code>。</p></blockquote><p><strong>我的思路：</strong> 直接用unordered_set统计两个数组出现的元素，然后比较哪些一样。<br><strong>代码随想录：</strong> 用了很多的小tips，例如容器支持迭代器初始化，不用一个一个的放进去。见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; inter;</span><br><span class="line">        std::unordered_set&lt;<span class="type">int</span>&gt; set1,set2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            set<span class="number">1.</span><span class="built_in">emplace</span>(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            set<span class="number">2.</span><span class="built_in">emplace</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:set1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set<span class="number">2.</span><span class="built_in">count</span>(s)!=<span class="number">0</span>)&#123;</span><br><span class="line">                inter.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums<span class="number">1.</span>begin(), nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、202快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。「快乐数」 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li><li>如果这个过程 结果为 1，那么这个数就是快乐数。</li><li>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</li></ul><p><strong>我的思路：</strong> ：这道题我的第一感觉是快乐数好像没啥特殊性质可以简化迭代，只有一直判断下去到最后才知道是不是快乐数。最后等于1那就是快乐数，最后一直循环了那就不是快乐数。我用一个<code>unordered_set</code>存储出现过的元素，每次生成新元素就进行判断看它是否再集合里，如果在则循环就不是快乐数。<br><em><strong>如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></em> 代码随想录的方法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        std::unordered_set&lt;<span class="type">int</span>&gt; his;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(his.<span class="built_in">find</span>(n)==his.<span class="built_in">end</span>())&#123; <span class="comment">// 循环条件：没有出现过</span></span><br><span class="line">            his.<span class="built_in">emplace</span>(n); <span class="comment">// 存储出现过的元素</span></span><br><span class="line">            <span class="keyword">auto</span> str_n = std::<span class="built_in">to_string</span>(n);</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str_n.<span class="built_in">size</span>())&#123;</span><br><span class="line">                n+=std::<span class="built_in">pow</span>((str_n[i]-<span class="string">&#x27;0&#x27;</span>),<span class="number">2</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123; <span class="comment">//一直取余</span></span><br><span class="line">        sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4、1两数之和</h1><p><strong>我的思路：</strong> ：这道题我想的还是遍历的思想，看快指针之前的元素能不能有和他成对儿的。复杂度是 O(n*n)。<br><strong><a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong> ：使用一个Hashmap去存出现过的元素和它的索引，在迭代的过程中不断判断是否有元素可以和当前元素成对儿。<strong>这个map和我的内层for循环是一样的作用，但是却可以以O(1)的复杂度找到目标。</strong></p><p><strong>总结tips：</strong> <font color='red'> 如果你要用循环去找一个数，而这个循环中的大部分元素总是被重复操作，可以考虑使用HashMap。 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;i;j++)&#123;  <span class="comment">// O(n)</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; re = &#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> re;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = maps.<span class="built_in">find</span>(target - nums[i]);  <span class="comment">// O(1)</span></span><br><span class="line">            <span class="keyword">if</span>(it!=maps.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;i,it-&gt;second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            maps.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;哈希表理论基础&lt;/h1&gt;
&lt;h2 id=&quot;什么时候用哈希法？&quot;&gt;什么时候用哈希法？&lt;/h2&gt;
&lt;p&gt;当我们遇到了要&lt;strong&gt;快速判断一个元素是否出现集合里&lt;/strong&gt;的时候，就要考虑哈希法。&lt;/p&gt;
&lt;h2 id=&quot;Hash表&quot;&gt;Hash表&lt;/h2&gt;
&lt;p&gt;数</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode面试经典150道</title>
    <link href="https://photin1a.github.io/posts/1b084fc8.html"/>
    <id>https://photin1a.github.io/posts/1b084fc8.html</id>
    <published>2025-01-12T14:50:00.000Z</published>
    <updated>2025-01-12T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>2025.1.12</h1><h2 id="88-合并两个有序数组">88. 合并两个有序数组</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><ul><li>双指针</li></ul><p><strong>我的解题思路</strong> ：题目要求合并后的数组仍然放在nums1上，与<code>合并两个有序链表</code>不同的是，<strong>数组的当前位置存储最大值时会覆盖原来的元素</strong>，而链表不会，因为链表可以断开再连。我使用的方法是创建数组存储合并后的数据，最后移动语义到nums1上。<br><strong>其他思路</strong> ：看了官方的另外一种解题思路很巧妙。<strong>直接从后往前排序，这样就不用担心元素覆盖的问题</strong>，因为本来后面就没元素（或者说都是零）。更巧妙的是，从后往前排时数组1后面剩余的空位置永远够排序，根本不用担心排到最后会覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(m+n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,cur = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; m &amp;&amp; p2 &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                nums[cur] = nums1[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[cur] = nums2[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == m)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2&lt;n)&#123;</span><br><span class="line">                nums[cur++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p1&lt;m)&#123;</span><br><span class="line">                nums[cur++] = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 官方在这里使用for循环重新赋值了一下。由于时c++我可以用移动语义。</span></span><br><span class="line">        nums1 = std::<span class="built_in">move</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode官方的解法3 逆向双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode官方的解法1 </span></span><br><span class="line"><span class="comment">// 先把nums2复制在nums1后面，然后调用sort()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="27-移除元素">27. 移除元素</h2><p><strong>我的思路：</strong> 简单。快指针在前面探路找不同与val的值，慢指针在后面赋值。</p><ul><li>快慢双指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h2><p><strong>我的思路：</strong> 简单。快指针在前面探路找不同与val的值，慢指针在后面赋值。关键在于那个值是之前没出现过的值，所以需要个map或者数组记录一下之前出现过哪些值，出现了几次。这里要注意使用<code>map[]</code>索引是如果不存在该元素，则会常见一个默认值为0的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, low = <span class="number">0</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[nums[fast]] &lt; <span class="number">1</span>)&#123;   <span class="comment">//不允许重复元素</span></span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[fast]]++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="80-删除有序数组中的重复项-II">80. 删除有序数组中的重复项 II</h2><p><strong>我的思路：</strong> 和<code>26. 删除有序数组中的重复项</code>类似，只是题目改了允许重复一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, low = <span class="number">0</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[nums[fast]] &lt; <span class="number">2</span>)&#123;    <span class="comment">//允许重复一个元素</span></span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[fast]]++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="169-多数元素">169. 多数元素</h2><p>多数元素：返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。<br><strong>我的思路：</strong> 多数元素其实就是出现次数最多的元素并且次数<code>&gt;n/2</code>，题目说一定有多数元素，所以直接找最多的元素就行。首先要用一个<code>unordered_map</code>或者数组记录各个元素出现的次数。有两个思路，第一个就是记录的过程中就不断的去比较谁次数多，保留最多的那个。第二种就是先记录，最后再找最大值。</p><p><strong>leetcode：</strong> :上面我的思路是找出现次数最多的元素，但是<strong>针对于多数元素的特殊性质，把元素排序，那么多数元素n/2的位置一定有。</strong> 这样就解决了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="type">int</span> item = nums[<span class="number">0</span>],maxsize = <span class="number">1</span>;</span><br><span class="line">        maps[item]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            maps[nums[i]]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( maps[nums[i]]&gt;maxsize)&#123;</span><br><span class="line">                maxsize = maps[nums[i]];</span><br><span class="line">                item = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            maps[nums[i]]++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> com = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;left,<span class="type">const</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 别用std::max函数</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max_element</span>(maps.<span class="built_in">begin</span>(),maps.<span class="built_in">end</span>(),com)-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1>2025.1.13</h1>]]></content>
    
    
    <summary type="html">为了offer而战</summary>
    
    
    
    <category term="LeetCode面试经典150道" scheme="https://photin1a.github.io/categories/LeetCode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%81%93/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
</feed>
