<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Photinia</title>
  
  
  <link href="https://photin1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://photin1a.github.io/"/>
  <updated>2025-04-01T14:33:00.000Z</updated>
  <id>https://photin1a.github.io/</id>
  
  <author>
    <name>Photinia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>openvla复现记录-环境配置</title>
    <link href="https://photin1a.github.io/posts/20af9ceb.html"/>
    <id>https://photin1a.github.io/posts/20af9ceb.html</id>
    <published>2025-04-01T14:33:00.000Z</published>
    <updated>2025-04-01T14:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 云端GPU算力平台</h1><p>若本地部署–&gt;需安装nvidia显卡驱动（略过）–安装nvidia显卡库CUDA12.4<br><a href="https://photin1a.github.io/posts/dfa33bbd.html">点此链接查看安装教程（不同驱动对应不同CUDA版本）</a></p><blockquote><p>我的显卡驱动版本为550.78，对应可最高使用CUDA12.4，对应使用torch2.4以上，python3.10<br><strong>记住这个组合，后面要用</strong>（cuda12.4+python3.10+torch2.5.1+torchvision0.20.1+torchaudio2.5.1）</p></blockquote><h2 id="1-1-购买套餐">1.1 购买套餐</h2><p>本文使用彗星云云服务器为例。官网购买后确保已经自带了cuda库。购买后即可通过ssh或者vnc远程连接。<code>ssh vipuser@js2.blockelite.cn -p 17536</code></p><blockquote><p><a href="https://gpu.ai-galaxy.cn/store">彗星云GPU服务器</a><br>套餐：GeForce RTX4090(24G显存) ￥1.39/h<br>系统镜像：ubuntu22.04_cuda12.4+miniconda</p></blockquote><h2 id="1-2-安装python3-10">1.2 安装python3.10</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y software-properties-common</span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y python3.10</span><br><span class="line">python3.10 --version</span><br></pre></td></tr></table></figure><h2 id="1-3-科学上网（没有特殊需求可以不做）">1.3 科学上网（没有特殊需求可以不做）</h2><p>（使用scp将自己的clash传到云服务器，这是我自己的操作）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /home/photinia/Downloads/clash_sub.txt vipuser@js1.blockelite.cn:/home/vipuser</span><br><span class="line">scp /home/photinia/Downloads/Clash\ <span class="keyword">for</span>\ Windows-0.20.7-x64-linux.tar.xz vipuser@js1.blockelite.cn:/home/vipuser</span><br></pre></td></tr></table></figure><h1>2. openvla部署</h1><h2 id="2-1-虚拟环境">2.1 虚拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虚拟环境</span></span><br><span class="line">conda create -n openvla python=3.10 -y</span><br><span class="line">conda activate openvla</span><br><span class="line"><span class="comment"># 换阿里源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><blockquote><p>note：如果系统未找到conda？<br>case1：你没有需要安装（需要网上找教程安装）<br>case2：存在目录~/miniconda3，但是没有添加环境变量在~/.bashrc里（需要在~/.bashrc里添加）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在~/.bashrc里添加，注意：将vipuser改为你的用户名</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by &#x27;conda init&#x27; !! </span></span><br><span class="line">__conda_setup=<span class="string">&quot;<span class="subst">$(&#x27;/home/vipuser/miniconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$__conda_setup</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;/home/vipuser/miniconda3/etc/profile.d/conda.sh&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line">        . <span class="string">&quot;/home/vipuser/miniconda3/etc/profile.d/conda.sh&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">&quot;/home/vipuser/miniconda3/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-部署openvla">2.2 部署openvla</h2><ol><li>clone 仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Clone and install the openvla repo</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openvla/openvla.git</span><br></pre></td></tr></table></figure><ol start="2"><li>./openvla/pyproject.toml中修改依赖的torch版本</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dependencies = [</span><br><span class="line">    &quot;accelerate&gt;=0.25.0&quot;,</span><br><span class="line">    &quot;draccus==0.8.0&quot;,</span><br><span class="line">    &quot;einops&quot;,</span><br><span class="line">    # &quot;flash_attn==2.5.5&quot;,      # Here for documentation -- install *AFTER* editable install (follow README)</span><br><span class="line">    &quot;huggingface_hub&quot;,</span><br><span class="line">    &quot;json-numpy&quot;,</span><br><span class="line">    &quot;jsonlines&quot;,</span><br><span class="line">    &quot;matplotlib&quot;,</span><br><span class="line">    &quot;peft==0.11.1&quot;,</span><br><span class="line">    &quot;protobuf&quot;,</span><br><span class="line">    &quot;rich&quot;,</span><br><span class="line">    &quot;sentencepiece==0.1.99&quot;,</span><br><span class="line">    &quot;timm==0.9.10&quot;,</span><br><span class="line">    &quot;tokenizers==0.19.1&quot;,</span><br><span class="line">    &quot;torch==2.5.1&quot;,  #修改1 </span><br><span class="line">    &quot;torchvision==0.20.1&quot;,#修改2</span><br><span class="line">    &quot;torchaudio==2.5.1&quot;,#修改3</span><br><span class="line">    &quot;transformers==4.40.1&quot;,</span><br><span class="line">    &quot;wandb&quot;,</span><br><span class="line">    &quot;tensorflow==2.15.0&quot;,</span><br><span class="line">    &quot;tensorflow_datasets==4.9.3&quot;,</span><br><span class="line">    &quot;tensorflow_graphics==2021.12.3&quot;,</span><br><span class="line">    &quot;dlimp @ git+https://github.com/moojink/dlimp_openvla&quot;</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>安装依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openvla</span><br><span class="line">pip install -e . </span><br><span class="line"></span><br><span class="line">pip install packaging ninja</span><br><span class="line">ninja --version; <span class="built_in">echo</span> $?  <span class="comment"># Verify Ninja --&gt; should return exit code &quot;0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 很慢，还可能会网络错误，建议去github上找到合适自己的版本，然后手动下载</span></span><br><span class="line"><span class="comment"># 去下载合适的版本，注意cuda、pytorch、python版本对应。cp310指python3.10 </span></span><br><span class="line"><span class="comment"># 链接：https://github.com/Dao-AILab/flash-attention/releases/</span></span><br><span class="line"><span class="comment"># 然后手动安装 pip install ./flash_attn-2.7.3+cu12torch2.5cxx11abiFALSE-cp310-cp310-linux_x86_64.whl</span></span><br><span class="line">pip install <span class="string">&quot;flash-attn==2.7.3&quot;</span> --no-build-isolation <span class="comment">#long time，如果失败，就手动安装</span></span><br></pre></td></tr></table></figure><h2 id="2-3-配置仿真环境">2.3 配置仿真环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install -r experiments/robot/libero/libero_requirements.txt</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Lifelong-Robot-Learning/LIBERO.git</span><br><span class="line"><span class="built_in">cd</span> LIBERO</span><br><span class="line">pip install -e .</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h2 id="2-4-去openvla仓库下载预训练模型">2.4 去openvla仓库下载预训练模型</h2><p><a href="https://huggingface.co/openvla">huggingface官网</a>（下载过程慢，建议科学上网）<br><a href="https://hf-mirror.com/">huggindface国内镜像</a>（镜像网站的下载速度只有7M不到）</p><blockquote><p>注意：由于本文只仿真，所以需要下载的是libero的数据集模型版本，例如 libero_spatial<br><img src="./20af9ceb/openvla_model.png" alt=""></p></blockquote><h1>3. openvla仿真–预训练模型</h1><h2 id="3-1-部署网上的openvla复现版本">3.1 部署网上的openvla复现版本</h2><ol><li>clone</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/niejnan/OpenVLA.git</span><br></pre></td></tr></table></figure><p>安装可能发生缺少的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install accelerate==0.25.0  <span class="comment">#版本太高不行</span></span><br><span class="line">pip install bitsandbytes</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件<br>在<code>./OpenVLA/config.py</code>文件中替换自己的模型路径<br>训练&amp;<a href="http://xn--readme-hu8ix05acqyxn0ftbta31jpym.md">运行参考该仓库readme.md</a></li></ol>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    model_family: <span class="built_in">str</span> = <span class="string">&quot;openvla&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改为自己下载的模型路径</span></span><br><span class="line">    pretrained_checkpoint: <span class="built_in">str</span> = <span class="string">&quot;/home/vipuser/openvla/openvla-7b-finetuned-libero-spatial&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ol start="3"><li>修改OpenVLA/eval.py</li></ol>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.norm_stats 怎么来的</span></span><br><span class="line"><span class="comment"># 设置配置的 unnorm_key 等于模型的 norm_stats ，用于数据的归一化</span></span><br><span class="line">config.task_suite_name: <span class="built_in">str</span> = <span class="string">&quot;libero_spatial&quot;</span>  <span class="comment">#对应下载的openvla-7b-finetuned-libero-spatial模型</span></span><br><span class="line">config.unnorm_key = config.task_suite_name</span><br></pre></td></tr></table></figure><ol start="4"><li>运行仿真（使用刚刚下载的预训练模型）</li></ol>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python OpenVLA/<span class="built_in">eval</span>.py</span><br></pre></td></tr></table></figure><ol start="5"><li>可能出现错误：</li></ol><ul><li>错误1<br><img src="./20af9ceb/%E9%94%99%E8%AF%AF1.png" alt=""></li></ul><p>解决：降低accelerate版本，pip install accelerate==0.25.0 `.</p><blockquote><p><a href="https://blog.csdn.net/2402_89926293/article/details/145517199">https://blog.csdn.net/2402_89926293/article/details/145517199</a></p></blockquote><ol start="6"><li>仿真结果</li></ol><blockquote><p>成功率16/20 = 80%。左侧成功，右侧失败。</p></blockquote><iframe src="//player.bilibili.com/player.html?bvid=BV1Z7Z1Y3EE8&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="//player.bilibili.com/player.html?bvid=BV1Z7Z1Y3EGD&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ol><li>仿真结果疑惑<ol><li>在失败的案例中，大多都是抓空。为什么抓空他不会继续抓，而是空着去目标点？？是所谓的泛华能力弱？</li><li>有一次失败机械臂几乎没有动</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1. 云端GPU算力平台&lt;/h1&gt;
&lt;p&gt;若本地部署–&amp;gt;需安装nvidia显卡驱动（略过）–安装nvidia显卡库CUDA12.4&lt;br&gt;
&lt;a href=&quot;https://photin1a.github.io/posts/dfa33bbd.html&quot;&gt;点此链接查看</summary>
      
    
    
    
    <category term="具身智能" scheme="https://photin1a.github.io/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/"/>
    
    <category term="openvla" scheme="https://photin1a.github.io/categories/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/openvla/"/>
    
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三十三天|122买卖股票的最佳时机II|55跳跃游戏|45跳跃游戏II|1005K次取反后最大化数组和</title>
    <link href="https://photin1a.github.io/posts/182d079a.html"/>
    <id>https://photin1a.github.io/posts/182d079a.html</id>
    <published>2025-02-12T04:14:00.000Z</published>
    <updated>2025-02-12T04:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、买卖股票的最佳时机II"><a href="#1、买卖股票的最佳时机II" class="headerlink" title="1、买卖股票的最佳时机II"></a>1、买卖股票的最佳时机II</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。</p><p><strong>我的思路</strong>：首先画出图来，然后大致看了一下发现多个小区间的利润加起来会超过大区间的利润。举了几个例子都是这样。于是写出了代码运行正确。如下图。<br><img src="./182d079a/买卖股票的最佳时机II.jpg" alt=""></p><p><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> diff = prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">            sum = diff&gt;<span class="number">0</span>?(sum+diff):sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2、55跳跃游戏"><a href="#2、55跳跃游戏" class="headerlink" title="2、55跳跃游戏"></a>2、55跳跃游戏</h1><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p><p>我的思路：没做出来。</p><p><a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：这个问题转化为跳跃覆盖范围究竟可不可以覆盖到终点！维护一个覆盖范围，遍历覆盖范围内的元素，当覆盖范围包含目标元素时返回。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230203105634.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> backidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>() &amp;&amp; i&lt;=backidx;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(backidx&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            backidx = (i+nums[i])&gt;backidx?(i+nums[i]):backidx; <span class="comment">//更新覆盖范围。覆盖范围内的元素一定可达</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="3、45跳跃游戏II"><a href="#3、45跳跃游戏II" class="headerlink" title="3、45跳跃游戏II"></a>3、45跳跃游戏II</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#1、买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;1、买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;1、买卖股票的最佳时机II&lt;/h1&gt;&lt;p&gt;给你一个整数数组 prices ，其中 prices</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="贪心算法" scheme="https://photin1a.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>nvidia驱动、cuda、python、pytorch版本对照表</title>
    <link href="https://photin1a.github.io/posts/dfa33bbd.html"/>
    <id>https://photin1a.github.io/posts/dfa33bbd.html</id>
    <published>2025-02-11T03:15:00.000Z</published>
    <updated>2025-02-11T03:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>cuda-显卡驱动对照表</h1><p>详细参考<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">官网</a>，部分对照如下：<br><a href="https://developer.nvidia.com/cuda-toolkit-archive"><strong>官网CUDA安装链接</strong></a></p><p><img src="./dfa33bbd/%E9%A9%B1%E5%8A%A8-cuda.png" alt=""></p><h1>cuda-pytorch-python版本对照</h1><blockquote><p><a href="https://blog.csdn.net/weixin_41809117/article/details/141246957">原文链接</a></p></blockquote><p><img src="./dfa33bbd/cuda-pytorch-python.png" alt=""></p><h1>cuda-pytorch官网对照</h1><p>参考<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ROCM 6.1 (Linux only)</span></span><br><span class="line">pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/rocm6.1</span><br><span class="line"><span class="comment"># ROCM 6.2 (Linux only)</span></span><br><span class="line">pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/rocm6.2</span><br><span class="line"><span class="comment"># CUDA 11.8</span></span><br><span class="line">pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu118</span><br><span class="line"><span class="comment"># CUDA 12.1</span></span><br><span class="line">pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu121</span><br><span class="line"><span class="comment"># CUDA 12.4</span></span><br><span class="line">pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu124</span><br><span class="line"><span class="comment"># CPU only</span></span><br><span class="line">pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cpu</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;cuda-显卡驱动对照表&lt;/h1&gt;
&lt;p&gt;详细参考&lt;a href=&quot;https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html&quot;&gt;官网&lt;/a&gt;，部分对照如下：&lt;br&gt;
&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="python" scheme="https://photin1a.github.io/categories/python/"/>
    
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>python学习记录</title>
    <link href="https://photin1a.github.io/posts/f2c9eeb3.html"/>
    <id>https://photin1a.github.io/posts/f2c9eeb3.html</id>
    <published>2025-02-09T21:54:00.000Z</published>
    <updated>2025-02-09T21:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、anaconda虚拟环境使用</h1><h2 id="安装">安装</h2><p>虚拟环境是一个 Python 环境，其中安装的 Python 解释器、库和脚本与安装在其他虚拟环境中的那些是隔离的。<strong>（相当于装了另一套python包）</strong><br><a href="https://www.anaconda.com/download/success">官网下载</a>，只用虚拟环境可以下载<code>miniconda</code>,然后直接运行脚本安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建环境</span></span><br><span class="line">conda create -n ENV_NAME python=3.9</span><br><span class="line"><span class="comment">#激活环境</span></span><br><span class="line">conda activate ENV_NAME</span><br><span class="line"><span class="comment">#退出环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"><span class="comment">#删除环境</span></span><br><span class="line">conda <span class="built_in">env</span> remove -n ENV_NAME</span><br></pre></td></tr></table></figure><h2 id="包管理">包管理</h2><p>在虚拟环境中可通过 pip 命令来进行管理，常用的包管理命令如下（以 requests 包为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装包：</span></span><br><span class="line">pip install requests_package</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装指定版本</span></span><br><span class="line">pip install requests==2.18.4</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装requirements.txt里列出的所有包</span></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#升级包：</span></span><br><span class="line">pip install --upgrade requests_package</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载包：</span></span><br><span class="line">pip uninstall requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出环境中的所有包清单</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h1>常用tips</h1><h2 id="类方法和静态方法">类方法和静态方法</h2><ol><li>类方法<br>类方法是定义在类中的方法，通过装饰器​​@classmethod​​来标识。<blockquote><p>我的理解。类方法为提供了一个类的<strong>单例</strong>实现。用@classmethod声明，cls理解为单例指针。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  class_attr = <span class="number">10</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls, x</span>): </span><br><span class="line">      <span class="comment"># 在类方法中可以访问类的属性</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;Class attribute: <span class="subst">&#123;cls.class_attr&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;Received value: <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="comment"># 通过类名调用类方法</span></span><br><span class="line">MyClass.class_method(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过实例对象调用类方法</span></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.class_method(<span class="number">7</span>)</span><br></pre></td></tr></table></figure></li><li>静态方法：同c++</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、anaconda虚拟环境使用&lt;/h1&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;虚拟环境是一个 Python 环境，其中安装的 Python 解释器、库和脚本与安装在其他虚拟环境中的那些是隔离的。&lt;strong&gt;（相当于装了另一套python包）&lt;/strong</summary>
      
    
    
    
    <category term="python" scheme="https://photin1a.github.io/categories/python/"/>
    
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三十二天|455分发饼干|376摆动序列|53最大子序和</title>
    <link href="https://photin1a.github.io/posts/f7631cda.html"/>
    <id>https://photin1a.github.io/posts/f7631cda.html</id>
    <published>2025-02-08T08:20:00.000Z</published>
    <updated>2025-02-08T15:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a></h1><blockquote><p><font color=red><strong>贪心算法其实就是没有什么规律可言。</strong></font>没有思路就立刻看题解。<br>基本贪心的题目有两个极端，要不就是特简单，要不就是死活想不出来。</p></blockquote><p><strong>贪心的本质</strong>：贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p><h2 id="什么时候用贪心">什么时候用贪心</h2><p>贪心算法并没有固定的套路。就是常识性推导加上举反例子。刷题或者面试的时候，<strong>手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例</strong>，那么就试一试贪心。</p><h2 id="贪心一般解题步骤">贪心一般解题步骤</h2><p>做题的时候，只要想清楚 <strong>局部最优</strong> 是什么，如果推导出全局最优，其实就够了。</p><h1>1、455分发饼干</h1><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p><p><strong>我的思路</strong>：我想每个人在饼干里找离他最能饱饼干，把饼干排序，这样查找时快一些。测试了一下 <code>21/25超时</code>。结果应该是对的，但是超时。于是我把食量也排序，这样找过的饼干前面的就不看了，<code>23/25超时</code>还是超时。<br><strong><a href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：人<strong>从后往前遍历</strong>找饼干。简便了很多。下图1是代码随想录的，从后往前只需看当前饼干能不能满足孩子胃口，不能那这个孩子就不用看了，往前的饼干也不可能满足。很经典。。图1是我的，从前往后，当前饼干不满足孩子胃口，但是后面的饼干更大，可能满足，我还得接着遍历饼干，时间复杂度更高。<br><img src="./f7631cda/tanxin.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 23/25 超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(s.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">            std::<span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">            std::<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> lastj = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;g.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = lastj;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="comment">// if(used[j] == true)continue;</span></span><br><span class="line">                    <span class="keyword">if</span>(s[j] &lt; g[i])<span class="keyword">continue</span>;</span><br><span class="line">                    used[j] = <span class="literal">true</span>;</span><br><span class="line">                    num++;</span><br><span class="line">                    lastj = j<span class="number">+1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">            std::<span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">            std::<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = g.<span class="built_in">size</span>()<span class="number">-1</span>, j = s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; <span class="number">0</span> || s[j] &lt; g[i])<span class="keyword">continue</span>;</span><br><span class="line">                num++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、376摆动序列</h1><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。<br>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><p><strong>我的思路</strong>：没做出来。这题暂时不做了。贪心。<br><strong><a href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。<br>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、53最大子序和</h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6</p><p><strong>我的思路</strong>：没做出来。贪心真的想不到。只能用用回溯做。<br><strong><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。全局最优：选取最大“连续和”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) &#123; <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) count = <span class="number">0</span>; <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html&quot;&gt;理论基础&lt;/a&gt;&lt;/h1&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="贪心算法" scheme="https://photin1a.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三十一天|491递增子序列|46全排列|47全排列II|332重新安排行程|51N皇后|37解数独</title>
    <link href="https://photin1a.github.io/posts/31c2c19.html"/>
    <id>https://photin1a.github.io/posts/31c2c19.html</id>
    <published>2025-02-08T05:43:00.000Z</published>
    <updated>2025-02-08T08:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、491递增子序列</h1><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>我的思路</strong>：没做出来。这道题返回的是序列，并不允许重新排序，所以这道题不好对树层进行去重。<br><strong>代码随想录</strong>：可以每一层迭代/递归都用一个 <code>unordered_set</code> 去统计出现过的元素。下一次直接判断元素是否出现过即可。<br><strong>优化</strong>：注意题目中说了，数值范围[-100,100]。所以可以用数组直接来做Hash查询，会比set快很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startidx,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(startidx &gt;= nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())<span class="keyword">continue</span>; <span class="comment">// 剪枝，递减序列</span></span><br><span class="line">                <span class="keyword">if</span>(uset.<span class="built_in">find</span>(nums[i])!=uset.<span class="built_in">end</span>())<span class="keyword">continue</span>; <span class="comment">//剪枝，用uset去重</span></span><br><span class="line">                uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startidx,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(startidx &gt;= nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> uset[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//使用&#123;&#125;初始化，没有初始化的元素将被初始化为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())<span class="keyword">continue</span>; <span class="comment">// 剪枝，递减序列</span></span><br><span class="line">                <span class="keyword">if</span>(uset[nums[i]<span class="number">+100</span>]==<span class="number">1</span>)<span class="keyword">continue</span>; <span class="comment">//剪枝，用uset去重</span></span><br><span class="line">                uset[nums[i]<span class="number">+100</span>]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h1>2、46全排列</h1><p>给定一个<strong>不含重复数字</strong>的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p><strong>我的思路</strong>：组合和排列有很明显的区别，组合不走回头路[1,2]和[2,1]是一样的，但是对于排列确是两种不同的序列。所以<strong>组合不走回头路，排列可以走回头路</strong>。</p><ul><li>走回头路意味着不需要<code>startidx</code>记录起始索引</li><li>和组合一样，同一候选元素不能多次使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; &amp;used, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、47全排列II</h1><p>给定一个可<strong>包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p><strong>我的思路</strong>：和<code>46全排列</code>不同，这题候选元素可能包含重复数字，所以需要<strong>树层去重</strong>，去重逻辑和组合一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; &amp;used, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)<span class="keyword">continue</span>;<span class="comment">// 排列特有的，树枝元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)<span class="keyword">continue</span>; <span class="comment">//树层去重</span></span><br><span class="line">            path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>; </span><br><span class="line">            </span><br><span class="line">            std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">traverse</span>(nums,used,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、332重新安排行程</h1><blockquote><p>二刷再做</p></blockquote><h1>5、51N皇后</h1><blockquote><p>二刷再做</p></blockquote><h1>6、37解数独</h1><blockquote><p>二刷再做</p></blockquote><h1><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><strong>代码随想录-回溯总结篇</strong></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、491递增子序列&lt;/h1&gt;
&lt;p&gt;给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。&lt;/p&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="排列-组合" scheme="https://photin1a.github.io/tags/%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三十天|93复原IP地址|78子集|90子集II</title>
    <link href="https://photin1a.github.io/posts/9d8f50cc.html"/>
    <id>https://photin1a.github.io/posts/9d8f50cc.html</id>
    <published>2025-02-08T04:00:00.000Z</published>
    <updated>2025-02-08T05:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、93复原IP地址</h1><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,“255.255.111.35”]</li></ul><p><strong>我的思路</strong>：<code>131分割回文串</code>类似，这道题是分割IP地址。不是回文串的就要剪枝，这题同样不是有效的IP元素的也要剪枝。先写出多叉树，再写递归逻辑。<font color = red><strong>遇到回溯的题先在纸上把问题画为多叉树演化一遍，不然很多细节想不到。</strong></font></p><p><strong><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：在原串上插入&quot;.&quot;来分割，不新建串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(string &amp;s,<span class="type">int</span> startidx, <span class="type">int</span> depth, string &amp;path, vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(startidx == s.<span class="built_in">size</span>())&#123; <span class="comment">// 截止条件，搜索完IP</span></span><br><span class="line">                <span class="keyword">if</span>(depth == <span class="number">5</span>)&#123; <span class="comment">// 检查IP是否四个段</span></span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(path.<span class="built_in">substr</span>(<span class="number">0</span>,path.<span class="built_in">size</span>()<span class="number">-1</span>));<span class="comment">// remove &quot;.&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(depth == <span class="number">4</span>)&#123;</span><br><span class="line">                    i = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isIPItem</span>(s,startidx,i))<span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="type">int</span> sub_size = i-startidx<span class="number">+1</span>; </span><br><span class="line">                path.<span class="built_in">append</span>(s,startidx,sub_size);</span><br><span class="line">                path+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                <span class="built_in">traverse</span>(s,i<span class="number">+1</span>,depth<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>(); <span class="comment">// remove &quot;.&quot;</span></span><br><span class="line">                path.<span class="built_in">erase</span>(path.<span class="built_in">size</span>()-sub_size,sub_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isIPItem</span><span class="params">(string &amp;s,<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start != end &amp;&amp; s[start]==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 0x 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>((end-start)&gt;<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//剪枝，最大范围255为三位</span></span><br><span class="line">            cout &lt;&lt; end-start &lt;&lt;endl;</span><br><span class="line">            <span class="type">int</span> ipitem = std::<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(start,end-start<span class="number">+1</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &gt; ipitem || ipitem &gt; <span class="number">255</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            string path;</span><br><span class="line">            vector&lt;string&gt; res;</span><br><span class="line">            <span class="built_in">traverse</span>(s,<span class="number">0</span>,<span class="number">1</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result;<span class="comment">// 记录结果</span></span><br><span class="line">    <span class="comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123; <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">            <span class="comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, i)) &#123; <span class="comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>);  <span class="comment">// 在i的后面插入一个逗点</span></span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointNum);   <span class="comment">// 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">                pointNum--;                         <span class="comment">// 回溯</span></span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);         <span class="comment">// 回溯删掉逗点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 不合法，直接结束本层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123; <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> result; <span class="comment">// 算是剪枝了</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、78子集</h1><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的<br>子集（幂集）。解集不能包含重复的子集。你可以按 任意顺序 返回解集。</p><p><strong>我的思路</strong>：典型的组合问题。由于组合的个数没有限制，所以不需要往后剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startidx,vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">if</span>(startidx == nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,path,res);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、90子集II</h1><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的<br>子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><strong>我的思路</strong>：与<code>78子集</code>不同，这题的候选元素有重复。候选元素重复要考虑<strong>树层去重</strong>和<strong>树枝去重</strong>两种情况。这里单个子集中的元素可以重复，例如[1,2,2]，实际上两个2来自两个不同的元素。<strong>所以这题只用树层去重</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startidx, vector&lt;<span class="type">bool</span>&gt; &amp;used, vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">if</span>(startidx &gt;= nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; used[i<span class="number">-1</span>]==<span class="literal">false</span>)<span class="keyword">continue</span>; </span><br><span class="line">                path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">traverse</span>(nums,i<span class="number">+1</span>,used,path,res);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">traverse</span>(nums,<span class="number">0</span>,used,path,res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、93复原IP地址&lt;/h1&gt;
&lt;p&gt;有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="组合" scheme="https://photin1a.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十九天|39组合总和|40组合总和II|131分割回文串</title>
    <link href="https://photin1a.github.io/posts/81a907dc.html"/>
    <id>https://photin1a.github.io/posts/81a907dc.html</id>
    <published>2025-02-05T10:35:00.000Z</published>
    <updated>2025-02-05T10:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、39组合总和</h1><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>提示：</p><ul><li>2 &lt;= candidates[i] &lt;= 40 ==&gt;意味着不会出现0，导致无穷多组合计；全为正意味着sum递增，不会出现一直递归下去的情况，总会遇到target边界。</li></ul><p><strong>我的思路</strong>：这道题和一般的组合不同。数字可以重复选取，意味着j可以从i开始，k可以从j开始，因此也不需要剪枝。另一点是这道题递归的层数并不固定，找到target就返回。 下面是组合的框架，只适用于候选元素互不相同时。<br><img src="./81a907dc/combinnation.jpg" alt=""><br><a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> startidx,<span class="type">int</span> sum, <span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)<span class="keyword">return</span>; <span class="comment">// 截止条件，由于元素&gt;0，所以继续递归下去不会出现sum == target了</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123; </span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(candidates,i,sum+candidates[i],target,path,res); <span class="comment">// 不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">traverse</span>(candidates,<span class="number">0</span>,<span class="number">0</span>,target,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、40组合总和II</h1><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p><strong>我的思路</strong>：和上一题<code>39组合总和</code>不同，这题候选元素有重复，则带重复元素的组合也会有重复。所以<strong>需要去重</strong>。另外元素不允许多次选取。<br><strong><a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：去重，其实就是 <strong>(单层for循环内/递归同一深度)</strong> 使用过的元素不能重复选取。我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。强调一下，树层去重的话，需要对数组排序！<br><img src="./81a907dc/combin_repeat.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,vector&lt;<span class="type">bool</span>&gt; &amp;used, <span class="type">int</span> startidx,<span class="type">int</span> sum, <span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)<span class="keyword">return</span>; <span class="comment">// 截止条件，由于元素&gt;0，所以继续递归下去不会出现sum == target了</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123; </span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(candidates,used,i<span class="number">+1</span>,sum+candidates[i],target,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        std::<span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">traverse</span>(candidates,used,<span class="number">0</span>,<span class="number">0</span>,target,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、131分割回文串</h1><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。</p><ul><li>输入：s = “aab”</li><li>输出：[[“a”,“a”,“b”],[“aa”,“b”]]</li></ul><p><strong>我的思路</strong>：先用多叉树表示出分割的过程。然后使用回溯的递归框架就可以。<br><img src="./81a907dc/huiwen.jpg" alt=""><br><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(string &amp;s,<span class="type">int</span> startidx, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startidx == s.<span class="built_in">size</span>())&#123; <span class="comment">// 截止条件，搜索完回文串</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isHuiwen</span>(s,startidx,i))<span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            path.<span class="built_in">emplace_back</span>(s,startidx,i-startidx<span class="number">+1</span>);</span><br><span class="line">            <span class="built_in">traverse</span>(s,i<span class="number">+1</span>,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHuiwen</span><span class="params">(string &amp;s,<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start++]!=s[end--])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; path;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="built_in">traverse</span>(s,<span class="number">0</span>,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、39组合总和&lt;/h1&gt;
&lt;p&gt;给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。&lt;br&gt;
</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="组合" scheme="https://photin1a.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十八天|理论基础|77组合|216组合总和III|17电话号码的字母组合</title>
    <link href="https://photin1a.github.io/posts/ea0d66b9.html"/>
    <id>https://photin1a.github.io/posts/ea0d66b9.html</id>
    <published>2025-02-05T06:30:00.000Z</published>
    <updated>2025-02-05T10:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>理论基础</h1><ol><li>回溯是递归的副产品，只要有递归就会有回溯。<font color=red><strong>回溯函数也就是递归函数</strong></font>，指的都是一个函数。</li><li>回溯法并不是什么高效的算法。回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。</li><li>如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</li></ol><h2 id="既然回溯法并不高效为什么还要用它呢？">既然回溯法并不高效为什么还要用它呢？</h2><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><h2 id="回溯法解决的问题–-排列组合">回溯法解决的问题–&gt;排列组合</h2><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="框架模板">框架模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(路径，参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (nextnodes) &#123;</span><br><span class="line">        <span class="comment">//处理节点;</span></span><br><span class="line">        <span class="built_in">backtracking</span>(路径，参数); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1、77组合</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。</p><p><strong>我的思路</strong>：没做出来。。一开始我直接使用 <code>递归/回溯</code> 框架，但是结果有重复，如何去重？<br><img src="./ea0d66b9/permutation.jpg" alt=""><br><img src="./ea0d66b9/combinnation.jpg" alt=""><br><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：可以剪枝优化。对于递归的最后几个元素构不成组合。<br><img src="./ea0d66b9/jianzhi.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的排问题迭代框架</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;...)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j&lt;...)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">1</span>;k&lt;...)</span><br><span class="line">        i!=j j!=k</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的组合问题迭代框架，不走回头路</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;...)</span><br><span class="line">    <span class="keyword">for</span>(j = i<span class="number">+1</span>;j&lt;...)</span><br><span class="line">        <span class="keyword">for</span>(k = j<span class="number">+1</span>;k&lt;...)</span><br><span class="line"><span class="comment">//组合+剪枝</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;len-k ...)</span><br><span class="line">    <span class="keyword">for</span>(j = i<span class="number">+1</span>;j&lt;len-k<span class="number">+1</span> ...)</span><br><span class="line">        <span class="keyword">for</span>(k = j<span class="number">+1</span>;k&lt;len-k<span class="number">+2</span> ...)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span>(k = j;k&lt;len ...)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后我写的，未剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rec, <span class="type">int</span> dep,<span class="type">int</span> k, <span class="type">int</span> startidx, <span class="type">int</span> endidx, vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep == k)&#123; <span class="comment">//截止条件</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;=endidx-k+dep<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(rec[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(rec,dep<span class="number">+1</span>,k,i<span class="number">+1</span>,endidx,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        path.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="built_in">traverse</span>(rec,<span class="number">0</span>,k,<span class="number">0</span>,rec.<span class="built_in">size</span>()<span class="number">-1</span>,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//剪枝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rec, <span class="type">int</span> dep,<span class="type">int</span> k, <span class="type">int</span> startidx, <span class="type">int</span> endidx, vector&lt;<span class="type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep == k)&#123; <span class="comment">//截止条件</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;=endidx-k+dep<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(rec[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(rec,dep<span class="number">+1</span>,k,i<span class="number">+1</span>,endidx,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        path.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="built_in">traverse</span>(rec,<span class="number">0</span>,k,<span class="number">0</span>,rec.<span class="built_in">size</span>()<span class="number">-1</span>,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、216组合总和III</h1><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 最多使用一次<br>返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</li></ul><p><strong>我的思路：</strong> 和上一题一样。只需在截止条件处进行判断即可。<br><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rec, <span class="type">int</span> dep,<span class="type">int</span> k, <span class="type">int</span> startidx, <span class="type">int</span> endidx, vector&lt;<span class="type">int</span>&gt; &amp;path,<span class="type">int</span> sum, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep == k)&#123; <span class="comment">//截止条件</span></span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startidx;i&lt;=endidx-k+dep<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(rec[i]);</span><br><span class="line">            <span class="built_in">traverse</span>(rec,dep<span class="number">+1</span>,k,i<span class="number">+1</span>,endidx,path,sum+rec[i],n,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        path.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="built_in">traverse</span>(rec,<span class="number">0</span>,k,<span class="number">0</span>,rec.<span class="built_in">size</span>()<span class="number">-1</span>,path,<span class="number">0</span>,n,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、17电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt=""></p><p><strong>我的思路</strong>：一开始还愣了一下，思路有点不清晰。这道题关键在于8个按键的字母是独立的，所以不用关心重复问题。<br><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><p><strong>小总结</strong>：遇到这种题有点模糊啊的话，就直接先用迭代for写出来框架，然后再用递归整理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(str[<span class="number">0</span>]的元素 )</span><br><span class="line">    <span class="keyword">for</span>(str[<span class="number">1</span>]的元素 )</span><br><span class="line">        <span class="keyword">for</span>(str[<span class="number">2</span>]的元素 )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;string&gt; &amp;res,string &amp;path,<span class="type">int</span> depth, string &amp;digits,unordered_map&lt;<span class="type">char</span>,string&gt; &amp;mem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = (digits[depth]==<span class="string">&#x27;7&#x27;</span>||digits[depth]==<span class="string">&#x27;9&#x27;</span>)?<span class="number">4</span>:<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            path+=mem[digits[depth]][i];</span><br><span class="line">            <span class="built_in">traverse</span>(res,path,depth<span class="number">+1</span>, digits,mem);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,string&gt; mem=&#123;&#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;abc&quot;</span>&#125;,&#123;<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>&#125;,&#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>&#125;,&#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>&#125;,&#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>&#125;,&#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">traverse</span>(res,path,<span class="number">0</span>, digits,mem);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">        string letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>();                       <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;理论基础&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;回溯是递归的副产品，只要有递归就会有回溯。&lt;font color=red&gt;&lt;strong&gt;回溯函数也就是递归函数&lt;/strong&gt;&lt;/font&gt;，指的都是一个函数。&lt;/li&gt;
&lt;li&gt;回溯法并不是什么高效的算法。回溯的本质是穷举，穷举</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="回溯" scheme="https://photin1a.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="组合" scheme="https://photin1a.github.io/tags/%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十七天|669修剪二叉搜索树|108将有序数组转换为二叉搜索树|538把二叉搜索树转换为累加树|二叉树总结</title>
    <link href="https://photin1a.github.io/posts/9cf8583e.html"/>
    <id>https://photin1a.github.io/posts/9cf8583e.html</id>
    <published>2025-02-05T03:15:00.000Z</published>
    <updated>2025-02-05T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、669修剪二叉搜索树</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。<br><strong>我的思路</strong>： 使用构造二叉树的遍历框架。节点的左子树一定小于节点，所以如果这个节点值小于下界low则遍历右子树。节点的右子树一定大于节点，所以如果这个节点值大于上界high则遍历左子树。<br><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low)<span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;high)<span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、108将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵<br><strong>平衡二叉搜索树</strong>。<br><strong>平衡二叉搜索树</strong>：指该树所有节点的左右子树的高度相差不超过 1。</p><p><strong>我的思路</strong>：没做出来。<br><strong><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">代码随想录</a></strong>：以中间节点作为根节点构建的二叉树就是平衡二叉搜索树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解了之后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> index = (start+end)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(nums,start,index<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(nums,index<span class="number">+1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、538把二叉搜索树转换为累加树</h1><p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt=""><br><strong>我的思路</strong>：要保证所有元素大于或等于原来的值之和。只需要从右往左中序遍历累加即可。可以用构造二叉树的框架，也可以用遍历二叉树的框架。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;lastval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(root-&gt;right,lastval);</span><br><span class="line">        root-&gt;val += lastval; <span class="comment">//中</span></span><br><span class="line">        lastval = root-&gt;val;</span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(root-&gt;left,lastval);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> lastval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,lastval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123; <span class="comment">// 右中左遍历</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">        cur-&gt;val += pre;</span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录二叉树总结</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、669修剪二叉搜索树&lt;/h1&gt;
&lt;p&gt;给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二十天|235二叉搜索树的最近公共祖先|701二叉搜索树中的插入操作|450删除二叉搜索树中的节点</title>
    <link href="https://photin1a.github.io/posts/722de76.html"/>
    <id>https://photin1a.github.io/posts/722de76.html</id>
    <published>2025-02-04T12:19:00.000Z</published>
    <updated>2025-02-05T03:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、235二叉搜索树的最近公共祖先</h1><p><strong>二叉搜索树特性</strong>：中序遍历是单调序列。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><blockquote><p>对于二叉搜索树，左树小于root，右树大于root。给定两个节点p和q，如果p小于root,q大于root，pq一定位于root的两边（两棵子树）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt;= root-&gt;val &amp;&amp; q-&gt;val &gt;= root-&gt;val)<span class="keyword">return</span> root;  <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt;= root-&gt;val &amp;&amp; q-&gt;val &lt;= root-&gt;val)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; p-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录，没写终止条件的情况。因为左右和终止条件是互补的，左右不满足返回cur就是终止条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="comment">// 左</span></span><br><span class="line">            TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="comment">// 右</span></span><br><span class="line">            TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、701二叉搜索树中的插入操作</h1><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><p><strong>我的思路：</strong> 一开始没想出来。看了代码随想录就会了。<br><img src="./722de76/insert.jpg" alt=""><br>这里提供两种思路，第一种在局部重构，第二种比较推荐，递归遍历找到空节点就加上。</p><p><strong>代码随想录</strong>：用的构造二叉树的那个框架。思路更清晰。推荐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看了代码随想录的思路后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">traverse</span>(root-&gt;left,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">traverse</span>(root-&gt;right,val);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);;</span><br><span class="line">        <span class="built_in">traverse</span>(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、450删除二叉搜索树中的节点</h1><p><strong>我的思路</strong>：没做出来。看了代码随想录后我写了，思路是先递归找到需要删除节点key的父节点，然后把key的1子树接上，2子树再递归接在1上。思路比较复杂。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt=""><br><strong><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：依然使用构造二叉树的框架去删除节点。整体逻辑清晰很多。<font color = red><strong>有一个关键点，由于右子树一定大于左子树，那么右子树一定接在左子树的右侧第一个nullptr上。反过来同理。</strong></font>这省去查找的麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入子树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse2</span><span class="params">(TreeNode* root,TreeNode* insert)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(insert == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(insert-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;left = insert;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;left,insert);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(insert-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;right = insert;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;right,insert);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = root-&gt;left-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;left = root-&gt;left-&gt;left;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;left,temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;left = root-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = root-&gt;right-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root-&gt;right = root-&gt;right-&gt;left;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;right,temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;right = root-&gt;right-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)<span class="built_in">traverse</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)<span class="built_in">traverse</span>(root-&gt;right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">traverse2</span>(root-&gt;right,root-&gt;left);</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我写的递归构造框架--删除元素 同代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right!=<span class="literal">nullptr</span>)<span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;right!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 右子树接在左子树最右边</span></span><br><span class="line">                <span class="keyword">auto</span> temp = root-&gt;left; <span class="comment">//左子树</span></span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;right)temp = temp-&gt;right;</span><br><span class="line">                temp-&gt;right = root-&gt;right;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left; <span class="comment">//返回左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left,key);</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、235二叉搜索树的最近公共祖先&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树特性&lt;/strong&gt;：中序遍历是单调序列。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十八天|530二叉搜索树的最小绝对差|501二叉搜索树中的众数|236二叉树的最近公共祖先</title>
    <link href="https://photin1a.github.io/posts/6e8fafd0.html"/>
    <id>https://photin1a.github.io/posts/6e8fafd0.html</id>
    <published>2025-02-04T05:29:00.000Z</published>
    <updated>2025-02-04T12:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、530二叉搜索树的最小绝对差</h1><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值。差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>我的思路</strong>：先中序遍历得到二叉树的单调序列，然后检查每查询相邻两个之间的最小值。也可以不记录序列，只记录上一个差值就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;midseq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, midseq);</span><br><span class="line">        midseq.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, midseq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; midseq;</span><br><span class="line">        <span class="built_in">traverse</span>(root,midseq);</span><br><span class="line">        <span class="type">int</span> mindiff = std::<span class="built_in">abs</span>(midseq[<span class="number">1</span>]-midseq[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;midseq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> dif = std::<span class="built_in">abs</span>(midseq[i]-midseq[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dif &lt; mindiff)&#123;</span><br><span class="line">                mindiff = dif;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mindiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、501二叉搜索树中的众数</h1><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p><strong>我的思路</strong>：先用中序遍历得到一个递增序列，然后用双指针去序列里寻找频率最高的元素。其实我认为也可以直接当普通二叉树来处理，递归遍历存储节点出现频率再HashMap中，最后在map里寻找最大值。</p><p><strong><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：也是两种思路，首先通用二叉树遍历用HashMap存储，然后转为vector排序（map不能排序）。第二种他是直接在递归的过程中就计算频率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;midseq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, midseq);</span><br><span class="line">        midseq.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, midseq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; midseq;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pq;</span><br><span class="line">        <span class="built_in">traverse</span>(root,midseq);</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; midseq.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; midseq.<span class="built_in">size</span>() &amp;&amp; midseq[left]==midseq[right])&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((right-left) == maxnum)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(midseq[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((right-left) &gt; maxnum)&#123;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(midseq[left]);</span><br><span class="line">                maxnum = right-left;</span><br><span class="line">            &#125;</span><br><span class="line">           left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、236二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><code>百度百科</code>中<strong>最近公共祖先的定义为</strong>：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>我的思路</strong>：没做出来。之前我一直想如果p或q是子树根节点，那我返回之后岂不是无法遍历到另一个节点了。后面看了代码随想录后懂了，返回之后就不要遍历另一个节点了，因为这个返回节点就是root，已经找到了。<br><strong><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* leftre = <span class="built_in">traverse</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* righre = <span class="built_in">traverse</span>(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftre != <span class="literal">nullptr</span> &amp;&amp; righre != <span class="literal">nullptr</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(leftre != <span class="literal">nullptr</span>)<span class="keyword">return</span> leftre;</span><br><span class="line">        <span class="keyword">if</span>(righre != <span class="literal">nullptr</span>)<span class="keyword">return</span> righre;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、530二叉搜索树的最小绝对差&lt;/h1&gt;
&lt;p&gt;给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值。差值是一个正数，其数值等于两值之差的绝对值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的思路&lt;/strong&gt;：先中序遍历得到二叉树的单调序列，然后</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十七天|654最大二叉树|617合并二叉树|700二叉搜索树中的搜索|98验证二叉搜索树</title>
    <link href="https://photin1a.github.io/posts/98db437f.html"/>
    <id>https://photin1a.github.io/posts/98db437f.html</id>
    <published>2025-02-02T14:50:00.000Z</published>
    <updated>2025-02-04T05:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、654最大二叉树</h1><p><strong>我的思路</strong>：和从<strong>前序、中序、后序重构二叉树</strong>的框架一样。应该重构二叉树都是一个框架。<br><a href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find max</span></span><br><span class="line">        <span class="type">int</span> maxval = nums[start];</span><br><span class="line">        <span class="type">int</span> idx = start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start<span class="number">+1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxval)&#123;</span><br><span class="line">                maxval = nums[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(maxval);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(nums,start,idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(nums,idx<span class="number">+1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、617合并二叉树</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt=""></p><p><strong>我的思路：</strong> 这道题还是递归的去构造二叉树就行，由于是两棵树所以参数是两个树节点。<br><strong><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 看了代码随想录之后发现我写的还是太冗余了。对于没有节点的位置我在树上虚拟了一个空节点。其实对于一个子树上没有节点的，直接把另一个树的子树接过来就ok。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                root1-&gt;val +=root2-&gt;val;</span><br><span class="line">                root = root1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(root1 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root1-&gt;left,</span><br><span class="line">                                root2 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(root1 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root1-&gt;right,</span><br><span class="line">                                root2 == <span class="literal">nullptr</span>?<span class="literal">nullptr</span>:root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录之后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> )<span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span> )<span class="keyword">return</span> root1;</span><br><span class="line">        </span><br><span class="line">        root1-&gt;val +=root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、700二叉搜索树中的搜索</h1><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。<br><strong>二叉搜索树</strong>：也称二叉排序树或二叉查找树。<br>非空左子树的所有键值小于其根结点的键值。<br>非空右子树的所有键值大于其根结点的键值。<br>左、右子树都是二叉搜索树。<br><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt=""></p><p><strong>我的思路：</strong> 利用二叉搜索树的性质就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || val == root-&gt;val)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、98验证二叉搜索树</h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><blockquote><p>遇到二叉搜索树，一定想着<strong>中序遍历</strong>，这样才能利用上特性。二叉搜索树中不能有重复元素。</p></blockquote><p><strong>我的思路</strong>：没做出来。<br><strong><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 代码随想录也是利用这个性质。先中序遍历，再检查遍历结果是否单调。我的和它的区别是我没有保存全部遍历结果，我<strong>只保留最后一个元素，节省内存</strong>。</p><p><strong>二叉搜索树中序遍历特性：</strong> 中序遍历下，输出的二叉搜索树节点的数值是有序序列。验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 了解了 二叉搜索树中序遍历特性 后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root, TreeNode* &amp;lastnode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(root-&gt;left,lastnode) == <span class="literal">false</span>)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span>(lastnode != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= lastnode-&gt;val)&#123;  <span class="comment">//中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastnode = root;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(root-&gt;right,lastnode) == <span class="literal">false</span>)<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* lastnode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,lastnode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、654最大二叉树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;我的思路&lt;/strong&gt;：和从&lt;strong&gt;前序、中序、后序重构二叉树&lt;/strong&gt;的框架一样。应该重构二叉树都是一个框架。&lt;br&gt;
&lt;a href=&quot;https://programmercarl.com/06</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十六天|513找树左下角的值|112路径总和|113路径综合II|106从中序与后序遍历序列构造二叉树|105从前序与中序遍历序列构造二叉树</title>
    <link href="https://photin1a.github.io/posts/28780bd.html"/>
    <id>https://photin1a.github.io/posts/28780bd.html</id>
    <published>2025-02-01T07:31:00.000Z</published>
    <updated>2025-02-02T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、513找树左下角的值</h1><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。<br><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt=""></p><p>我的思路：这道题<code>for循环</code>的层序遍历最好做。如果递归，就是要找到最大深度的第一个节点。<br><a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历，很简单</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        TreeNode* target = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> sz = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    target = node;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;maxDep,<span class="type">int</span> &amp;val, <span class="type">int</span> curDep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">// 截止条件</span></span><br><span class="line">            <span class="keyword">if</span>(curDep&gt;maxDep)&#123;</span><br><span class="line">                maxDep = curDep;</span><br><span class="line">                val = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;left,maxDep,val,curDep<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right,maxDep,val,curDep<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxDep = <span class="number">-1</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root,maxDep,val,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、112路径总和</h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 true ；否则，返回 false 。</p><p><strong>我的思路</strong>：递归解法。<br><strong>代码随想录</strong>：看了代码随想录后发现可以再继续优化，每次求累加实际上重复了，我们维护一个求和就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;TreeNode*&gt; &amp;path,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件-&gt;叶子节点</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node:path)&#123;</span><br><span class="line">                sum+=node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> sum == targetSum?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> le = <span class="literal">false</span>, ri = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            le = <span class="built_in">traverse</span>(root-&gt;left,path,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(le == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//遇到结果提前停止递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ri = <span class="built_in">traverse</span>(root-&gt;right,path,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(ri == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector&lt;TreeNode*&gt; path;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,path,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后的,,速度提升了很多</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> sum,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件-&gt;叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum == targetSum?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> le = <span class="literal">false</span>, ri = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            le = <span class="built_in">traverse</span>(root-&gt;left,sum+root-&gt;left-&gt;val,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(le == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ri = <span class="built_in">traverse</span>(root-&gt;right,sum+root-&gt;right-&gt;val,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(ri == <span class="literal">true</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,root-&gt;val,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、113路径综合II</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。</p><p><strong>我的思路：</strong> 关键在于求路径那就需要记录路径，顺序路径意味着前序遍历。<br><strong>代码随想录：</strong> 一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;paths, vector&lt;<span class="type">int</span>&gt; &amp;path, <span class="type">int</span> sum,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件-&gt;叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum)&#123;</span><br><span class="line">                paths.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;left,paths,path,sum+root-&gt;left-&gt;val,targetSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right,paths,path,sum+root-&gt;right-&gt;val,targetSum);</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; paths;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">traverse</span>(root,paths,path,root-&gt;val,targetSum);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、106从中序与后序遍历序列构造二叉树</h1><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。<br><img src="https://labuladong.online/algo/images/binary-tree-ii/5.jpeg" alt=""><br><strong>我的思路：</strong> 没做出来。核心还是要熟二叉树的前中后遍历结果。<br><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/#%E9%80%9A%E8%BF%87%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><strong>labuladong</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看了labuladong后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> instart, <span class="type">int</span> inend, <span class="type">int</span> poststart, <span class="type">int</span> postend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart &gt; inend)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postend]);</span><br><span class="line">        <span class="type">int</span> rootidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rootidx = instart; rootidx&lt;= inend; rootidx++)&#123;   <span class="comment">// 可以用一个Hashmap查阅，增大效率。</span></span><br><span class="line">            <span class="keyword">if</span>(inorder[rootidx] == root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lftsize = rootidx - instart;</span><br><span class="line">        <span class="type">int</span> rgtsize = inend - rootidx;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(inorder,postorder,instart,rootidx<span class="number">-1</span>,poststart,poststart+lftsize<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(inorder,postorder,rootidx<span class="number">+1</span>,inend,poststart+lftsize,postend<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(inorder,postorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>5、105从前序与中序遍历序列构造二叉树</h1><p><img src="https://labuladong.online/algo/images/binary-tree-ii/1.jpeg" alt=""></p><p><strong>我的思路：</strong> 和106一样。核心还是要熟二叉树的前中后遍历结果。<br><a href="https://labuladong.online/algo/data-structure/binary-tree-part2/#%E9%80%9A%E8%BF%87%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><strong>labuladong</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了labuladong后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; preorder, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> instart, <span class="type">int</span> inend, <span class="type">int</span> prestart, <span class="type">int</span> preend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart &gt; inend)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[prestart]);</span><br><span class="line">        <span class="type">int</span> rootidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rootidx = instart; rootidx&lt;= inend; rootidx++)&#123;   <span class="comment">// 可以用一个Hashmap查阅，增大效率。</span></span><br><span class="line">            <span class="keyword">if</span>(inorder[rootidx] == root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lftsize = rootidx - instart;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traverse</span>(inorder,preorder,instart,rootidx<span class="number">-1</span>,prestart<span class="number">+1</span>,prestart+lftsize);</span><br><span class="line">        root-&gt;right = <span class="built_in">traverse</span>(inorder,preorder,rootidx<span class="number">+1</span>,inend,prestart+lftsize<span class="number">+1</span>,preend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(inorder,preorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、513找树左下角的值&lt;/h1&gt;
&lt;p&gt;给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2020/12/14</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十五天|110平衡二叉树|257二叉树的所有路径|404左叶子之和|222完全二叉树的节点个数</title>
    <link href="https://photin1a.github.io/posts/57bd7082.html"/>
    <id>https://photin1a.github.io/posts/57bd7082.html</id>
    <published>2025-01-30T14:14:00.000Z</published>
    <updated>2025-02-01T07:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、110平衡二叉树</h1><p>给定一个二叉树，判断它是否是平衡二叉树。<br><strong>平衡二叉树</strong>：指该树所有节点的左右子树的高度相差不超过<code>1</code>。</p><p><strong>我的思路</strong>：这道题和最大深度不同，最大深度只需要递归返回最大深度，但是这里有两个信息需要返回，一个是返回节点高度来供父节点处理，二是当前节点不满足平衡就返回false。我把高度作为参数，返回值为是否平衡。<br><strong><a href="https://leetcode.cn/problems/balanced-binary-tree/">代码随想录</a></strong>：看了代码随想录，由于高度始终为正，所以可以把-1作为否平衡，&gt;0作为平衡。这样就只需要一个返回值，也就是当前节点的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* root,<span class="type">int</span> &amp;hig)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            hig = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> higl = <span class="number">0</span>,higr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(root-&gt;left,higl) == <span class="literal">false</span> || </span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right,higr) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(std::<span class="built_in">abs</span>(higl-higr)&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hig = <span class="number">1</span>+std::<span class="built_in">max</span>(higl,higr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root,hig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 判断-1就返回，不要等后序才返回，省时间</span></span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight); <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、257二叉树的所有路径</h1><p>给你一个二叉树的根节点 root ，按任意顺序 ，返回所有从根节点到叶子节点的路径。<br>叶子节点是指没有子节点的节点。</p><p><strong>我的思路：</strong> 我觉得这题的关键在于路径是从root指向叶子节点，也就是从上到下，所以可以使用前序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">// 中</span></span><br><span class="line">            string temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                temp+=std::<span class="built_in">to_string</span>(path[i])+<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp+=std::<span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//回溯</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left,path,res);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right,path,res);</span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path; </span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">traverse</span>(root,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、404左叶子之和</h1><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>我的思路：</strong> 递归的第一要素就是找到截止条件，一般遍历判断当前节点是否为空指针即可，但是对于一些特殊情况，比如要求左叶子节点就必须找到父节点。<br><a href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> le = <span class="number">0</span>,ri = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>)&#123; <span class="comment">//截止条件</span></span><br><span class="line">                le =  root-&gt;left-&gt;val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                le = <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ri = <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> le+ri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、222完全二叉树的节点个数</h1><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br><strong>完全二叉树定义</strong>：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ 2h 个节点。</p><p><strong>我的思路：</strong> 这道题第一眼看起来和求普通二叉树节点个数一样。选定返回值为当前节点以下的个数，则确定使用<strong>后序遍历</strong>。<br><strong><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 完全二叉树中大部分子树为满二叉树，对于满二叉树我们通过它的深度即可计算出节点个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通递归写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> le = <span class="built_in">countNodes</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> ri = <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+le+ri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截止条件：判断是不是满二叉树</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        <span class="type">int</span> leftdep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftdep++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> rightdep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightdep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftdep == rightdep)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftdep) - <span class="number">1</span>; <span class="comment">//注意(2&lt;&lt;1) 相当于2^2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left)+<span class="built_in">countNodes</span>(root-&gt;right); <span class="comment">//后序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、110平衡二叉树&lt;/h1&gt;
&lt;p&gt;给定一个二叉树，判断它是否是平衡二叉树。&lt;br&gt;
&lt;strong&gt;平衡二叉树&lt;/strong&gt;：指该树所有节点的左右子树的高度相差不超过&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的思路&lt;/strong&gt;：这道题和</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十四天|226翻转二叉树(递归)|101对称二叉树(递归)|104二叉树的最大深度(递归)|111二叉树的最小深度(递归)</title>
    <link href="https://photin1a.github.io/posts/553b0985.html"/>
    <id>https://photin1a.github.io/posts/553b0985.html</id>
    <published>2025-01-26T14:27:00.000Z</published>
    <updated>2025-01-30T14:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、226翻转二叉树</h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt=""><br><strong>我的思路：</strong> 懵了一会儿。遍历到当前节点时，需要将它的子节点交换一下。所以需要在<strong>前序位置</strong>做交换最合适。<br><strong><a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong>：递归遍历、DFS迭代遍历（栈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的递归遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录，DFS深度优先，迭代遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、101对称二叉树</h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>我的思路：</strong> 把树分为左子树和右子树，两棵树同时遍历比较。左子树从左到右，右子树从右到左。可以共用一个队列。我只想到层序遍历。<strong><font color='red'> 递归想不出来。两个子树同时递归怎么做？</font></strong><br><strong><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></strong>：看了代码随想录之后我发现好简单，<strong>递归函数参数多传一个节点就行。。</strong> <font color='gree'>我觉得难点在于如何判断使用哪种递归方式（前、中、后），以及递归返回值、递归参数怎样确定。</font><br><a href="https://www.bilibili.com/video/BV1ue4y1Y7Mf/?vd_source=d83fadd3138d002993b778881de0f2e9"><strong>视频</strong></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(root-&gt;left); <span class="comment">//left tree</span></span><br><span class="line">        pq.<span class="built_in">push</span>(root-&gt;right); <span class="comment">//right tree</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> left = pq.<span class="built_in">front</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> right = pq.<span class="built_in">front</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right!=<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            pq.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            pq.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            pq.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 看了代码随想录后我写的递归解法</span></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* tl,TreeNode* tr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="literal">nullptr</span> &amp;&amp; tr!=<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//终止递归的条件</span></span><br><span class="line">        <span class="keyword">if</span>(tl != <span class="literal">nullptr</span> &amp;&amp; tr==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="literal">nullptr</span> &amp;&amp; tr==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(tl-&gt;val != tr-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> out = <span class="built_in">traverse</span>(tl-&gt;left,tr-&gt;right);</span><br><span class="line">        <span class="type">bool</span> in = <span class="built_in">traverse</span>(tl-&gt;right,tr-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> out &amp;&amp; in;  <span class="comment">// 后序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、104二叉树的最大深度（递归解法）</h1><p><strong>我的思路：</strong> 这道题用递归解法来解。我把depth和max_depth作为递归函数参数。<strong><font color = red>我感觉我对递归函数返回值怎样设计一窍不通，导致很多变量我都放在参数里，没有返回值就意味着基本都是前序遍历。</font></strong></p><blockquote><p><strong>我的小思考</strong>：前序就是从上往下递归，后序就是从下往上收拢，所以后序一般用于返回值</p></blockquote><p><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：</p><ol><li><strong>确定递归函数的参数和返回值</strong>：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li><li><strong>确定终止条件</strong>：如果为空节点的话，就返回0，表示高度为0。</li><li><strong>确定单层递归的逻辑</strong>：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的递归解法，本质上还是前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, <span class="type">int</span> &amp;max_depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max_depth)&#123;  </span><br><span class="line">            max_depth = depth;  <span class="comment">// 中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left,depth<span class="number">+1</span>,max_depth); <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right,depth<span class="number">+1</span>,max_depth); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root,depth,max_depth);</span><br><span class="line">        <span class="keyword">return</span> max_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录递归解法，属于后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left_depth = <span class="built_in">traverse</span>(root-&gt;left); <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> right_depth = <span class="built_in">traverse</span>(root-&gt;right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+std::<span class="built_in">max</span>(left_depth,right_depth); <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、111二叉树的最小深度（递归解法）</h1><p><strong>我的思路：</strong> 受上一题的启发 --&gt; 递归最终的结果作为返回值，主要是找到截止条件。二叉树的遍历一般是判断当前指针是否为nullptr截止，但是最小深度需要判断子节点的全部是否为nullptr。</p><p><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#%E6%80%9D%E8%B7%AF"><strong>代码随想录</strong></a>：和我的思路一样，写的没我的绕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的递归解法 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left_depth = <span class="number">9999999</span>;</span><br><span class="line">        <span class="type">int</span> right_depth = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            left_depth = <span class="built_in">traverse</span>(root-&gt;left); <span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right_depth = <span class="built_in">traverse</span>(root-&gt;right); <span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+std::<span class="built_in">min</span>(left_depth,right_depth); <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、226翻转二叉树&lt;/h1&gt;
&lt;p&gt;给你一棵二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，翻转这棵二叉树，并返回其根节点。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2021/03/14/invert1-</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十三天|理论基础|二叉树的递归遍历（前、中、后）|二叉树的迭代遍历|二叉树的层序遍历</title>
    <link href="https://photin1a.github.io/posts/76e5d8f8.html"/>
    <id>https://photin1a.github.io/posts/76e5d8f8.html</id>
    <published>2025-01-24T04:04:00.000Z</published>
    <updated>2025-01-26T14:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>理论基础</h1><p><strong>二叉树的种类：</strong></p><ul><li>满二叉树：二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上</li><li>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。（例如大顶堆和小顶堆就是这种数据结构）</li><li>二叉搜索树：二叉搜索树是一个有序树，左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。</li><li>平衡二叉树：左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn。</strong></li></ul><h2 id="遍历框架">遍历框架</h2><h3 id="递归遍历（DFS）">递归遍历（DFS）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""></h3><h1>1、144二叉树的前序遍历、145二叉树的后序遍历、94二叉树的中序遍历</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2、二叉树的迭代遍历</h1><p>先放过</p><h1>3、二叉树的统一迭代法</h1><p>先放过</p><h1>4、二叉树的层序遍历</h1><p><strong><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">labuladong框架</a>：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// *****条件***** //</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、for循环记录层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="comment">// *****条件***** //</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-102二叉树的层序遍历">4.1 102二叉树的层序遍历</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br><strong>直接套框架:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res_t</span><span class="params">(num)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="type">res_t</span>[i] = cur-&gt;val;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="type">res_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-107二叉树的层序遍历II">4.2 107二叉树的层序遍历II</h2><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>我的思路：</strong> 比较容易想到的方法就是<strong>正常层序遍历</strong>然后最后<code>reverse</code>一下就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="4-3-199二叉树的右视图">4.3 199二叉树的右视图</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>我的思路：</strong> 和就是层序遍历，只不过每一层只要一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-637二叉树的层平均值">4.4 637二叉树的层平均值</h2><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><p><strong>我的思路：</strong> 还是带for循环版本的层序遍历。最后发现有一个案例，全是<code>int最小值</code>过不了。<code>64 / 66 个通过的测试用例。</code> 我用<code>int sum</code>去求和提示溢出，于是我把每个元素除以<code>size</code>先求平均值再相加。这样应该会损失精度。后面改为<code>long long sum</code>就可以了。测试<code>double sum</code>也可以。<code>double</code> 类型可以表示大约 <code>15-17</code> 位有效数字，用来表示整数<code>(10位左右)</code>足够了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 案例</span></span><br><span class="line">-2147483336-2147483647-2147483646-2147483647-2147483647-2147483647-2147483644-2147483647-2147483647-2147483525-2147483647-2147483647-2147483646-2147483646-2147483646 ...</span><br><span class="line"><span class="comment"># 我的输出</span></span><br><span class="line">[0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,0.00000,-0.00002]</span><br><span class="line"><span class="comment"># 正确输出</span></span><br><span class="line">[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> ave = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val!=<span class="number">0</span>)&#123;</span><br><span class="line">                    ave+=<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(cur-&gt;val)/num;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(ave);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了代码随想录后的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                sum+=cur-&gt;val;</span><br><span class="line">                </span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(sum/num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-5-429N叉树的层序遍历">4.5 429N叉树的层序遍历</h2><p><strong>我的思路：</strong> 简单，就是二叉树的拓展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(); </span><br><span class="line">        queue&lt;Node*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res_t</span><span class="params">(num)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="type">res_t</span>[i] = cur-&gt;val;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="type">node_t</span>:cur-&gt;children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="type">node_t</span>!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                        pq.<span class="built_in">push</span>(<span class="type">node_t</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="type">res_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-6-515在每个树行中找最大值">4.6 515在每个树行中找最大值</h2><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p><strong>我的思路：</strong> 层序遍历框架。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(); </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> max = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val &gt; max)&#123;</span><br><span class="line">                    max = cur-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-7-116填充每个节点的下一个右侧节点指针">4.7 116填充每个节点的下一个右侧节点指针</h2><p>给定一个 <strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt=""><br><strong>我的思路：</strong> 层序遍历。只是应该存储上一次的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的，代码不是很漂亮，思路是对的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> root; </span><br><span class="line">        queue&lt;Node*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> last = pq.<span class="built_in">front</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(last-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(last-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(last-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(last-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                last-&gt;next = cur;</span><br><span class="line">                last = cur;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// vector&lt;int&gt; vec;</span></span><br><span class="line">            Node* nodePre;</span><br><span class="line">            Node* node;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>(); <span class="comment">// 取出一层的头结点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node; <span class="comment">// 本层前一个节点next指向本节点</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-8-117填充每个节点的下一个右侧节点指针II">4.8 117填充每个节点的下一个右侧节点指针II</h2><p>Same to <code>4.7 116填充每个节点的下一个右侧节点指针</code></p><h2 id="4-9-104二叉树的最大深度">4.9 104二叉树的最大深度</h2><p>给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>我的思路：</strong> 层序遍历。每层计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-10">4.10</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。</p><p><strong>我的思路：</strong> 层序遍历。和最大深度区别是找到一个叶子节点就停。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        queue&lt;TreeNode*&gt;  pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = pq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = pq.<span class="built_in">front</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span> &amp;&amp; cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> depth<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;理论基础&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉树的种类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满二叉树：二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上&lt;/li&gt;
&lt;li&gt;完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="二叉树" scheme="https://photin1a.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十一天|150逆波兰表达式求值|239滑动窗口最大值|347前K个高频元素</title>
    <link href="https://photin1a.github.io/posts/780df565.html"/>
    <id>https://photin1a.github.io/posts/780df565.html</id>
    <published>2025-01-18T07:04:00.000Z</published>
    <updated>2025-01-18T07:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、150逆波兰表达式求值</h1><p><strong>我的思路：</strong> 看了代码随想录才做的。就觉得比较简单。<br><strong><a href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; com;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;tokens.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a*b);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a/b);</span><br><span class="line">            &#125;     </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a+b);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                b = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                a = com.<span class="built_in">top</span>();</span><br><span class="line">                com.<span class="built_in">pop</span>();</span><br><span class="line">                com.<span class="built_in">push</span>(a-b);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                com.<span class="built_in">push</span>(std::<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> com.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、239滑动窗口最大值</h1><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p><p><strong>我的思路：</strong> 没做出来。首先最直接能想到的是对每个滑动窗口都求一遍最大值，这样是挺简单的。但是，我们在滑动窗口的时候其实后面的窗口和前面的窗口是重叠的，如果对每个滑动窗口都求一遍最大值无疑是有很多重复计算。其实前面窗口排好序之后，后面的窗口也只需比较最后一个元素就能排序，再退一步，我们其实我们除了需要知道窗口里的元素，额外只要知道第二大的的元素就行，下一个窗口只要和第二大的元素或最大的元素比较就可以。<br><strong><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录</a>：</strong> 单调队列。单调队列维护所有具有单调性的元素。不更改元素的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录之后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>,left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right = <span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= k &amp;&amp; nums[right-k]==dq.<span class="built_in">front</span>())&#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[right]&gt;dq.<span class="built_in">back</span>())&#123;</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dq.<span class="built_in">emplace_back</span>(nums[right]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= k<span class="number">-1</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(dq.<span class="built_in">front</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123; <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、347前K个高频元素</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按任意顺序返回答案。</p><p><strong>我的思路：</strong> 很容易想到的思路，用一个map存储元素出现次数，最后对map排序一遍。如果使用<code>unordered_map</code>则不支持排序需要重新拷贝到<code>vector</code>里。<br><strong><a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>：</strong> 同样使用<code>map</code>去记录元素的频率，然后用一个<code>优先级队列（小顶堆）</code>去排序，优先级队列维持k的大小，这样排序只需要对k个元素排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;last,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> last.second &gt; cur.second;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(mp.<span class="built_in">begin</span>(), mp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp); <span class="comment">// 排序nlogn复杂度（以快排为例）</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:vec)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++&gt;=k)<span class="keyword">break</span>;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了代码随想录后写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;newit,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;oldit)&#123;</span><br><span class="line">            <span class="keyword">return</span> newit.second &gt; oldit.second;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:mp)&#123;  <span class="comment">// 维持pq的尺寸为k，那么每次排序logk复杂度，总的O(nlogk)（以快排为例）</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(it.second &gt; pq.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">                   pq.<span class="built_in">emplace</span>(it); </span><br><span class="line">                   pq.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(pq.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = res.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            res[j] = pq.<span class="built_in">top</span>().first;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、150逆波兰表达式求值&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;我的思路：&lt;/strong&gt; 看了代码随想录才做的。就觉得比较简单。&lt;br&gt;
&lt;strong&gt;&lt;a href=&quot;https://programmercarl.com/0150.%E9%80%86%E6%B3%A2</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="栈与队列" scheme="https://photin1a.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第十天|232用栈实现队列|225用队列实现栈|20有效的括号|1047删除字符串中的所有相邻重复项</title>
    <link href="https://photin1a.github.io/posts/6bc5198a.html"/>
    <id>https://photin1a.github.io/posts/6bc5198a.html</id>
    <published>2025-01-17T06:09:00.000Z</published>
    <updated>2025-01-17T06:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>栈与队列理论基础</h1><p><strong>栈和队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的</strong>（底层容器可替换）。<br>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><p>我们常用的<code>SGI STL</code>（gcc所使用的stl库）默认是以<code>deque</code>为缺省情况下栈的底层结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>&gt; third; <span class="comment">// 默认deque</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><h1>1、232用栈实现队列</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 true ；否则，返回 false</li></ul><p><strong>我的思路：</strong> 好吧。没做出来。<br><strong><a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 用两个栈一个进另一个再转进去弹出。<br><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; out;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> top = <span class="built_in">peek</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                out.<span class="built_in">push</span>(in.<span class="built_in">top</span>());</span><br><span class="line">                in.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>()&amp;&amp;out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、225用队列实现栈</h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p><strong>我的思路：</strong> 还是没做出来。。<br><strong><a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 使用一个队列就可以完成。一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、20有效的括号</h1><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li><li></li></ul><p><strong>我的思路：</strong> 这道题比较简单，依次符号入栈，然后下一个符号如果能和栈顶匹配就消去，和消消乐一样。<strong><font color='red'>但是问题是–要不是这节课学的就是栈，我可能想不到用栈去做。笔试时怎么办？</font></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、1047删除字符串中的所有相邻重复项</h1><p>给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><ul><li>输入：“abbaca”</li><li>输出：“ca”</li></ul><p><strong>我的思路：</strong> 和上一题<code>20有效的括号</code>一样，也是找到同类元素消除。开心消消乐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sta.<span class="built_in">top</span>()==s[i])&#123;</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res+=sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;栈与队列理论基础&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;栈和队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的&lt;/strong&gt;（底层容器可替换）。&lt;br&gt;
所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。&lt;/</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
    <category term="栈与队列" scheme="https://photin1a.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第九天|151翻转字符串里的单词|卡码网-55右旋转字符串|28实现strStr()|459重复的子字符串</title>
    <link href="https://photin1a.github.io/posts/5a27cff6.html"/>
    <id>https://photin1a.github.io/posts/5a27cff6.html</id>
    <published>2025-01-16T06:00:00.000Z</published>
    <updated>2025-01-16T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、151翻转字符串里的单词</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p><strong>我的思路：</strong> 首先这道题返回一个新串，不要求在原串上修改，所以简便很多。直接一个每个区域用双指针填充就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的。。比较水的解法。。。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> low = s.<span class="built_in">size</span>()<span class="number">-1</span>,fast = low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(fast&gt;=<span class="number">0</span> &amp;&amp; s[fast]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                fast--;</span><br><span class="line">            &#125;;</span><br><span class="line">            low = fast;</span><br><span class="line">            <span class="keyword">while</span>(fast&gt;=<span class="number">0</span> &amp;&amp; s[fast]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                fast--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">append</span>(s,fast<span class="number">+1</span>,low-fast);</span><br><span class="line">            res+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">back</span>()==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">代码随想录</a>：</strong> <strong>分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</strong></p><h2 id="提升：不要使用辅助空间，空间复杂度要求为O-1-。">提升：不要使用辅助空间，空间复杂度要求为O(1)。</h2><p>方法： &quot;the sky is blue &quot;</p><ul><li>移除多余空格：<code>&quot;the sky is blue&quot;</code> 对应<code>27移除元素</code></li><li>字符串反转：<code>&quot;eulb si yks eht&quot;</code>对应<code>344反转字符串</code></li><li>单词反转：<code>&quot;blue is sky the&quot;</code>对应<code>541反转字符串II</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了代码随想录后我写的</span></span><br><span class="line"><span class="comment">// 可以直接当模板拿来写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// remove extra /0x20  移除连续重复的元素</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(fast = <span class="number">0</span>;fast &lt; s.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fast]==<span class="string">&#x27; &#x27;</span> &amp;&amp; (fast==<span class="number">0</span> || s[fast<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>))<span class="keyword">continue</span>;</span><br><span class="line">            s[low++] = s[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> length = s[low<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>?low<span class="number">-1</span>:low;  <span class="comment">//最后可能有空格，长度需要-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// str reverse   // 字符串逆序</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = s[right];</span><br><span class="line">            s[right] = s[left];</span><br><span class="line">            s[left] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word reverse   //单词逆序</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &lt; length)&#123;</span><br><span class="line">            left = p;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; length &amp;&amp; s[p]!= <span class="string">&#x27; &#x27;</span>)p++;</span><br><span class="line">            right = p<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = s[right];</span><br><span class="line">                s[right] = s[left];</span><br><span class="line">                s[left] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s,<span class="number">0</span>,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、卡码网-55右旋转字符串</h1><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。<br>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p><p><strong>我的思路：</strong> 受前面一题<code>151翻转字符串里的单词</code> 的启发，可以先反转整个串，然后把对应的需要的部分反转。</p><p><strong>tips：</strong> 反转字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;str, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = start, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = str[right];</span><br><span class="line">        str[right] = str[left];</span><br><span class="line">        str[left] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rota</span><span class="params">(string &amp;str,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// reverse 所有字符</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(str,left,right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reverse 前k个字符</span></span><br><span class="line">    left = <span class="number">0</span>,right = k<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(str,left,right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reverse 剩下字符</span></span><br><span class="line">    left = k,right = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(str,left,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; str;</span><br><span class="line">    <span class="built_in">rota</span>(str,k);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3、28实现strStr()</h1><blockquote><p>二刷再做</p></blockquote><h1>4、459重复的子字符串</h1><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>我的思路：</strong> 使用for循环一个一个的匹配。看着简单，写起来还是有点发愣的，也用了30来分钟。O(n^2)复杂度。</p><p><strong><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录-移动匹配法</a>：</strong> 如果s是一个重复子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的暴力解法，leetcode通过了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()%i!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = l+i;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l]==s[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span>(l &gt;= i)&#123;</span><br><span class="line">                    l=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r == s.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = s + s;</span><br><span class="line">        t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>()); t.<span class="built_in">erase</span>(t.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">find</span>(s) != std::string::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// find调用库函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、151翻转字符串里的单词&lt;/h1&gt;
&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。&lt;br&gt;
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
</feed>
