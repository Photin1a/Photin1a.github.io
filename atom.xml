<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Photinia</title>
  
  
  <link href="https://photin1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://photin1a.github.io/"/>
  <updated>2025-01-12T14:50:00.000Z</updated>
  <id>https://photin1a.github.io/</id>
  
  <author>
    <name>Photinia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode面试经典150道</title>
    <link href="https://photin1a.github.io/posts/1b084fc8.html"/>
    <id>https://photin1a.github.io/posts/1b084fc8.html</id>
    <published>2025-01-12T14:50:00.000Z</published>
    <updated>2025-01-12T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>2025.1.12</h1><h2 id="88-合并两个有序数组">88. 合并两个有序数组</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><ul><li>双指针</li></ul><p><strong>我的解题思路</strong> ：题目要求合并后的数组仍然放在nums1上，与<code>合并两个有序链表</code>不同的是，<strong>数组的当前位置存储最大值时会覆盖原来的元素</strong>，而链表不会，因为链表可以断开再连。我使用的方法是创建数组存储合并后的数据，最后移动语义到nums1上。<br><strong>其他思路</strong> ：看了官方的另外一种解题思路很巧妙。直接从后往前排序，这样就不用担心元素覆盖的问题，因为本来后面就没元素（或者说都是零）。更巧妙的是，从后往前排时数组1后面剩余的空位置永远够排序，根本不用担心排到最后会覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(m+n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,cur = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; m &amp;&amp; p2 &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                nums[cur] = nums1[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[cur] = nums2[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == m)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2&lt;n)&#123;</span><br><span class="line">                nums[cur++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p1&lt;m)&#123;</span><br><span class="line">                nums[cur++] = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 官方在这里使用for循环重新赋值了一下。由于时c++我可以用移动语义。</span></span><br><span class="line">        nums1 = std::<span class="built_in">move</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode官方的解法3 逆向双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode官方的解法1 </span></span><br><span class="line"><span class="comment">// 先把nums2复制在nums1后面，然后调用sort()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="27-移除元素">27. 移除元素</h2><p><strong>我的思路：</strong> 简单。快指针在前面探路找不同与val的值，慢指针在后面赋值。</p><ul><li>快慢双指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h2><p><strong>我的思路：</strong> 简单。快指针在前面探路找不同与val的值，慢指针在后面赋值。关键在于那个值是之前没出现过的值，所以需要个map或者数组记录一下之前出现过哪些值，出现了几次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, low = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps.<span class="built_in">count</span>(nums[fast])==<span class="number">0</span>)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                maps.<span class="built_in">emplace</span>(nums[fast],<span class="number">1</span>);</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[fast]]++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1>2025.1.13</h1>]]></content>
    
    
    <summary type="html">为了offer而战</summary>
    
    
    
    <category term="LeetCode面试经典150道" scheme="https://photin1a.github.io/categories/LeetCode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%81%93/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Failed to connect to github.com port 443 after 21150 ms, Could not connect to server</title>
    <link href="https://photin1a.github.io/posts/d1a2de71.html"/>
    <id>https://photin1a.github.io/posts/d1a2de71.html</id>
    <published>2025-01-11T15:25:00.000Z</published>
    <updated>2025-01-11T15:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Failed to connect to <a href="http://github.com">github.com</a> port 443 after 21150 ms: Could not connect to server</h1><p><strong>什么是443端口号？</strong><br><strong>443端口是互联网上所有加密通信的通用端口，也是HTTPS所使用的端口号。</strong> <strong>HTTP 协议使用的是80端口</strong>处理所有入站和出站信息。但问题是 HTTP 协议不安全，因为所有数据都以纯文本形式从一台计算机传输到另一台计算机。</p><p><strong>你的梯子使用的是什么端口号？</strong><br>我的梯子是通过本地127.0.0.1:7890向代理服务器发送请求。也就是说，<strong>我如果想用梯子，我就得用7890端口向外部请求网络服务。</strong></p><hr><p><strong>问题：</strong><br>一般你用梯子设置代理ip端口之后，浏览器就会使用你设置的ip端口。但是git他却没有使用代理端口7890给我传东西，而是继续使用默认的443告诉我超时。<br><strong>解决：</strong><br>我们需要设置git的代理端口也为7890.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 方法1（不推荐）：全局设置，针对所有的git访问网址都代理</span></span><br><span class="line"><span class="comment">#使用http代理 </span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br><span class="line"><span class="comment">#使用socks5代理</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment">##方法2（推荐）：只对github代理，github只是用http</span></span><br><span class="line"><span class="comment">#使用socks5代理（推荐）</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:7890</span><br><span class="line"><span class="comment">#使用http代理（不推荐）</span></span><br><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p><strong>查询代理：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure><p><strong>取消代理：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">解决 git push 失败的问题</summary>
    
    
    
    <category term="疑难杂症" scheme="https://photin1a.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第四天|24两两交换链表中的节点|19删除链表的倒数第N个节点|面试题02.07链表相交|142环形链表II</title>
    <link href="https://photin1a.github.io/posts/8e38590b.html"/>
    <id>https://photin1a.github.io/posts/8e38590b.html</id>
    <published>2025-01-11T06:00:00.000Z</published>
    <updated>2025-01-11T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、24两两交换链表中的节点"><a href="#1、24两两交换链表中的节点" class="headerlink" title="1、24两两交换链表中的节点"></a>1、24两两交换链表中的节点</h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""> </p><blockquote><p><a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></blockquote><p>思路：拿到这道题看到时看到两两交换节点，就想到能不能用双指针，但是对于什么时候用双指针还是有点迷糊的。然后思考能不能用虚拟头节点，思考了以下我只是两两交换节点似乎不和虚拟头节点沾边，我没法用上。写着写着发现我把这两个节点交换时，好像涉及到要把之前的节点连上，把之后的节点连上，之后的节点可以使用cur指针找到，但是之前的节点没法啊。。。于是恍然大悟。.</p><p><strong>虚拟头节点、双指针总结：</strong> 在处理需要断键重连的链表问题时，如果一下子想不出来，<strong>优先思考可不可以用双指针</strong>，双指针第一个指针存储last节点，另一个则是cur节点，可以省去很多临时节点。如果第一个元素也需要处理，那就需要前面加上虚拟头节点，方便<strong>第一个元素也可以有last</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pre = &amp;dumy, *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = cur-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next-&gt;next = cur;</span><br><span class="line">        cur-&gt;next = tmp; </span><br><span class="line"></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了代码随想录之后看到他是直接用了一个指针，从虚拟头节点就开始，这样之后的节点就可以直接next.next…下去。我用双指针的话有last访问之前的节点。<br><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// 步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// 步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* result = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="2、19删除链表的倒数第N个节点"><a href="#2、19删除链表的倒数第N个节点" class="headerlink" title="2、19删除链表的倒数第N个节点"></a>2、19删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt=""></p><blockquote><p><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></blockquote><p><strong>思路：</strong> 这题之前看labuladong的博客时刷过，有两种方法：第一种时很直接的，先遍历一遍算出链表总长度l，然后l-n就是需要移除的下标，我们需要找到下标l-n-1的元素就可以移除l-n。第二种是用<strong>快慢双指针</strong>，快指针先走n步，然后慢指针才开始走，快指针走到头了慢指针对应的元素就是要移除的元素。这两种算法其实复杂度一样，但是双指针的显得更nb。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line">  ListNode *p = &amp;dumy;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  p =  &amp;dumy;</span><br><span class="line">  <span class="type">int</span> idx = i-n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(idx--)&#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>快慢双指针做法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line">    ListNode *fast = &amp;dumy, *low = &amp;dumy;</span><br><span class="line">    <span class="type">int</span> i = n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3、面试题02-07链表相交"><a href="#3、面试题02-07链表相交" class="headerlink" title="3、面试题02.07链表相交"></a>3、面试题02.07链表相交</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目数据 保证 整个链式结构中不存在环。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt=""></p><blockquote><p><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></blockquote><p><strong>思路：</strong> 这道题刷过，思路有两个。一是先遍历求各自的长度，然后长的先移动对其短的。另一种是同时遍历A、B链表，哪个遍历完就遍历下一个，这样就能保证两个遍历的一样多，直到遇上相同节点就结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = headA,*p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span> &amp;&amp; p2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4、142环形链表II"><a href="#4、142环形链表II" class="headerlink" title="4、142环形链表II"></a>4、142环形链表II</h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><blockquote><p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></blockquote><p><strong>思路：</strong> 这道题是判断链表是否有环，有则返回环点。之前刷过，思路上快慢双指针，快指针以两倍速走，慢指针一倍速走，如果有环则快指针早晚追上慢指针，如果没环最后会遇到<code>nullptr</code>。有一个注意的是：快慢指针相遇的位置并不一定是环点。我的思路是先找到相遇点，然后展开成两个链表相遇的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle1</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line">        ListNode *low = &amp;dumy,*fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(low == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB, ListNode *inse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *end = inse-&gt;next;</span><br><span class="line">        ListNode *p1 = headA,*p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p1 == end &amp;&amp; p2 == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p1 == end)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2 == end)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> inse = <span class="built_in">detectCycle1</span>(head);</span><br><span class="line">        <span class="keyword">if</span>(inse == <span class="literal">nullptr</span>) <span class="keyword">return</span> inse;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getIntersectionNode</span>(head,inse-&gt;next,inse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了<a href="https://www.bilibili.com/video/BV1q94y1X7vy/?spm_id_from=333.999.0.0&amp;vd_source=d83fadd3138d002993b778881de0f2e9">labuladong视频</a>和<a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF">文章</a>之后我悟了。他的做法也是先找环内点，然后双指针一个从头，一个从环内点开始，遇到的就是环起点。<br><img src="https://labuladong.online/algo/images/linked-two-pointer/3.jpeg" alt=""><br><img src="https://labuladong.online/algo/images/linked-two-pointer/2.jpeg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、24两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#1、24两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;1、24两两交换链表中的节点&quot;&gt;&lt;/a&gt;1、24两两交换链表中的节点&lt;/h1&gt;&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三天|链表理论|203移出链表元素|707设计链表|206翻转链表</title>
    <link href="https://photin1a.github.io/posts/c83e90c7.html"/>
    <id>https://photin1a.github.io/posts/c83e90c7.html</id>
    <published>2025-01-10T11:30:00.000Z</published>
    <updated>2025-01-10T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>单链表：</strong> 指针域只能指向节点的下一个节点。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt=""></li><li><strong>双链表：</strong> 每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表 既可以向前查询也可以向后查询。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt=""></li><li><p><strong>循环链表：</strong> 就是链表首尾相连。循环链表可以用来解决约瑟夫环问题。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png" alt=""></p></li><li><p>数组的元素是不能删的，只能覆盖。双链表 既可以向前查询也可以向后查询。</p></li></ul><hr><h1 id="1、203移出链表元素"><a href="#1、203移出链表元素" class="headerlink" title="1、203移出链表元素"></a>1、203移出链表元素</h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。<br><strong>思路</strong> ：这道题一开始我以为简单，就是简单的链表遍历。但是我忽略了一个小细节，导致卡了一会，就是<strong>只有当下一个节点值不是要求移出的值时才步进指针，因为是要求值的时候我们断键重连后其实节点已经更新了，下一个节点应该再次被检查，不能步进指针</strong>。<br><strong>知识点：</strong>虚拟头结点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dumy = <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)&#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2、-707设计链表"><a href="#2、-707设计链表" class="headerlink" title="2、 707设计链表"></a>2、 707设计链表</h1><p><strong>思路：</strong> 拿到这道题，一开始想的还是用单链表的遍历，这样每一个函数就都能写了。但是测试了运行13ms，击败42%的人，写的不是很好。估计得掌握双链表才能更快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    ListNode dumy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;next-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        dumy.next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,dumy.next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ == index)&#123;</span><br><span class="line">                cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,cur-&gt;next);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == index)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,cur-&gt;next);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ == index)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3、206反转链表"><a href="#3、206反转链表" class="headerlink" title="3、206反转链表"></a>3、206反转链表</h1><blockquote><p><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a><br>没写出来，,,,，没往双指针上去想。。。。。。。看了代码随想录之后感觉思路好清晰<br><img src="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp; <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            temp = cur-&gt;next;  <span class="comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">// 翻转操作</span></span><br><span class="line">            <span class="comment">// 更新pre 和 cur指针</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>递归写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head, ListNode *tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tail-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(head-&gt;next,tail);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail = <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="built_in">traverse</span>(head,&amp;tail);</span><br><span class="line">        <span class="keyword">return</span> tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单链表：&lt;/strong&gt; 指针域只能指向节点的下一个节点。&lt;br&gt;&lt;img src=&quot;https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png&quot; </summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二天|209长度最小的子数组|59螺旋矩阵II|977有序数组的平方|区间和、前缀和|开发商购买土地</title>
    <link href="https://photin1a.github.io/posts/f75317da.html"/>
    <id>https://photin1a.github.io/posts/f75317da.html</id>
    <published>2025-01-09T12:00:00.000Z</published>
    <updated>2025-01-09T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-知识点"><a href="#0-知识点" class="headerlink" title="0. 知识点"></a>0. 知识点</h1><ul><li>滑动窗口</li><li>前缀和数组</li></ul><h2 id="滑动窗口算法（快慢指针）"><a href="#滑动窗口算法（快慢指针）" class="headerlink" title="滑动窗口算法（快慢指针）"></a>滑动窗口算法（快慢指针）</h2><ul><li>滑动窗口算法技巧主要用来解决<strong>子数组、子串</strong>问题，比如让你寻找符合某个条件的最长/最短子数组。</li><li>它是一个左闭右开的区间</li><li>时间复杂度O(N)<br>思路：先移动右指针找到可行解，然后移动左指针找到最优解。然后再移动有指针。。。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    <span class="keyword">auto</span> window = ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c);</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和数组、矩阵"><a href="#前缀和数组、矩阵" class="headerlink" title="前缀和数组、矩阵"></a>前缀和数组、矩阵</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><a href="https://labuladong.online/algo/data-structure/prefix-sum/">lanuladong</a><br><img src="https://labuladong.online/algo/images/difference/1.jpeg" alt="前缀和数组创建"><br>求索引区间 <code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1]</code> 得出。</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="https://labuladong.online/algo/images/presum/5.jpeg" alt=""><br>维护和数组类似，对于m*n的矩阵，我们维护一个m+1*n+1的前缀和矩阵。<code>preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1]</code>。</p><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>学习时长：四个半小时。映像比较深刻的就是左闭右开很多时候会减少计算量。</p><h1 id="1、209长度最小的子数组"><a href="#1、209长度最小的子数组" class="headerlink" title="1、209长度最小的子数组"></a>1、209长度最小的子数组</h1><blockquote><p><a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">labuladong文章链接</a><br><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录文章链接</a><br><a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">视频链接</a><br>知识点：滑动窗口 </p></blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其总和大于等于 target 的长度最小的子数组[numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p><strong>思路：</strong> 拿到这道题首先看到是找<strong>最小串问题，优先考虑滑动窗口法</strong>。滑动窗口法的思路是<strong>先移动右指针找到可行解，然后移动左指针找到最优解</strong>。这里可行解是满足其总和大于等于 target，最优解是可行解中的最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">//初始时区间内没有数据，所以是左闭右开的区间</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minlen = std::<span class="built_in">numeric_limits</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右指针</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        sum+=nums[right]; <span class="comment">// 移入窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、移动右指针找到可行解，可行解的条件就是sum &gt;= target</span></span><br><span class="line">        <span class="comment">// 然后开始移动左指针</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="comment">// 2、移动左指针找到最优解，移出窗口</span></span><br><span class="line">            <span class="type">int</span> len = right-left;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;minlen)&#123;</span><br><span class="line">                minlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            sum-=nums[left]; </span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minlen==std::<span class="built_in">numeric_limits</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">max</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> minlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、59螺旋矩阵II"><a href="#2、59螺旋矩阵II" class="headerlink" title="2、59螺旋矩阵II"></a>2、59螺旋矩阵II</h1><blockquote><p><a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">labuladong文章链接</a><br><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录文章链接</a><br><a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">视频链接</a><br>知识点：滑动窗口 </p></blockquote><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p><strong>我的思路</strong>：拿到这一题我首先想到的就是按照题目所说的一圈一圈的填充矩阵。除此之外我再也想不到了。。。好好复盘了一下之前做的那些题，<strong>没做出来的原因并不是这些框架不会，而是没想出来怎么把这些题抽象成框架出来</strong>。。图穷匕见了，还是刷的少了。看了代码随想录之后我发现思路和我是一样的，但是在处理转圈问题上我做题时不够清晰，而且缺乏技巧，他是叠加一个一个的转圈，xy滚动叠加，而我每次重新计算,思路上比我得容易理解很多。还是刷的少了。<br>按照以上思路的暴力算法：击败6.74%的人，可怜。。。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=n<span class="number">-2</span>-i;j++)&#123;</span><br><span class="line">            mat[i][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=n<span class="number">-2</span>-i;j++)&#123;</span><br><span class="line">            mat[j][n<span class="number">-1</span>-i]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>-i;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[n<span class="number">-1</span>-i][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>-i;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[j][i]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        mat[n/<span class="number">2</span>][n/<span class="number">2</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>重新优化后好了很多，，但是<strong>我发现一般对于边界取不到优先使用左闭右开的区间会省去很多计算量</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k = n<span class="number">-1</span>-i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            mat[i][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            mat[j][k]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[k][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[j][i]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        mat[n/<span class="number">2</span>][n/<span class="number">2</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看了代码随想录的视频<strong>左闭右开</strong>：重新做了大幅提升速度<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>;start&lt;n/<span class="number">2</span>;start++)&#123;</span><br><span class="line">        <span class="type">int</span> x = start;</span><br><span class="line">        <span class="type">int</span> y = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;y&lt;n-start<span class="number">-1</span>;y++)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;n-start<span class="number">-1</span>;x++)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;y&gt;start;y--)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;x&gt;start;x--)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        mat[n/<span class="number">2</span>][n/<span class="number">2</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-知识点&quot;&gt;&lt;a href=&quot;#0-知识点&quot; class=&quot;headerlink&quot; title=&quot;0. 知识点&quot;&gt;&lt;/a&gt;0. 知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;滑动窗口&lt;/li&gt;
&lt;li&gt;前缀和数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;滑动窗口算法（快慢指针</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第一天|数组理论|704二分查找|24移除元素|977有序数组的平方</title>
    <link href="https://photin1a.github.io/posts/22bb52a8.html"/>
    <id>https://photin1a.github.io/posts/22bb52a8.html</id>
    <published>2025-01-08T10:07:00.000Z</published>
    <updated>2025-01-08T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、tips"><a href="#0、tips" class="headerlink" title="0、tips"></a>0、tips</h1><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的</li><li>数组的元素是不能删的，只能覆盖。</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>学习时长：三小时。今天的题都是比较基础的，直接运用算法框架就能写，977有序数组题没看仔细平方卡了一下。前面花时间右总结了一下二分法的框架和细节。</p><h1 id="1、704二分查找"><a href="#1、704二分查找" class="headerlink" title="1、704二分查找"></a>1、704二分查找</h1><blockquote><p><a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">labuladong文章链接</a><br><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">代码随想录文章链接</a><br><a href="https://www.bilibili.com/video/BV1fA4y1o715">视频链接</a>     </p></blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li>拿到这道排序题，首先看到是对有序数组查找一个数，可以使用二分查找，复杂度OlogN。对于二分查找有三种类型：查找一个数、查找左侧边界、查找右侧边界，每一种都可以用左闭右闭和左闭右开的方法去索引。</li></ul><p><strong>这里我掌握左闭右闭的二分框架。</strong></p><ul><li>思路：<ul><li>首先明确我使用左闭右闭的框架，即左右双指针都是即将搜索的区间边界。得到初始条件<code>int left = 0, right = nums.size()-1</code>  </li><li>然后明确循环条件，搜索有效的条件应该是左右边界重合。得到<code>left &lt;= right</code></li><li>最后保证每次循环更新的左右双指针都左闭右闭<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在框架中<code>mid = left + (right - left) / 2</code>和<code>(right + left)/2</code>结果相同，但是可以有效防止<code>left</code>和<code>right</code>太大，直接相加导致溢出的情况。</p></blockquote></li></ul></li></ul><p><strong>左闭右开：</strong></p><ul><li>思路：<ul><li>首先明确使用左闭右开的框架，即左指针是即将搜索的左区间边界，右指针是即将搜索的右区间边界+1。得到初始条件<code>int left = 0, right = nums.size()</code>  </li><li>然后明确循环条件，搜索有效的条件应该是左右边界重合。由于右指针是开区间，它的前一个才是右边界。得到<code>left &lt; right</code></li><li>最后保证每次循环更新的左右双指针都左闭右开<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid<span class="number">+1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="2、27移除元素"><a href="#2、27移除元素" class="headerlink" title="2、27移除元素"></a>2、27移除元素</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。<br>思路：快慢双指针解法，复杂度O(N)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">            nums[low] = nums[fast];</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3、977有序数组的平方"><a href="#3、977有序数组的平方" class="headerlink" title="3、977有序数组的平方"></a>3、977有序数组的平方</h1><p>给你一个按非递减顺序排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按非递减顺序排序。</p><p>首先拿到这一题，最先想到的是先平方，再排序，鉴于不怎么会排序算法就没继续深入想，用stl的排序这题就做的没啥水平了。<br>然后想到这个整数数组平方之后最大的数一定出现在左右两端，没有负数也就只有在右边。由于题目要求升序，那就要最大放右边，那可能我还要把最右边那个数交换到其他位置上，越来越复杂了，原因在于<strong>我受上一题影响以为要在原数组上改，其实题目要返回新数组，题目没看清。</strong></p><p>思路：左右双指针，复杂度O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">re</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> end = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> lv = nums[left]*nums[left];</span><br><span class="line">        <span class="type">int</span> rv = nums[right]*nums[right];</span><br><span class="line">        <span class="keyword">if</span>(lv &gt; rv)&#123;</span><br><span class="line">            re[end--] = lv;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re[end--] = rv;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0、tips&quot;&gt;&lt;a href=&quot;#0、tips&quot; class=&quot;headerlink&quot; title=&quot;0、tips&quot;&gt;&lt;/a&gt;0、tips&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数组下标都是从0开始的。&lt;/li&gt;
&lt;li&gt;数组内存空间的地址是连续的&lt;/li&gt;
&lt;li&gt;数组的</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>minco参数曲线化</title>
    <link href="https://photin1a.github.io/posts/58f47eff.html"/>
    <id>https://photin1a.github.io/posts/58f47eff.html</id>
    <published>2025-01-06T10:19:03.000Z</published>
    <updated>2025-01-06T10:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-微分平坦"><a href="#0-微分平坦" class="headerlink" title="0. 微分平坦"></a>0. 微分平坦</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于非线性系统的一般形式如下：</p><script type="math/tex; mode=display">\dot x = f(x,u,t)</script><p>如果系统这个系统通过化简或者变换后能够找到一组变量$y$，使得系统的状态量$x$和控制量$u$可以由$y$及$y$的多阶导数表示，则<strong>系统是微分平坦</strong>的。即：</p><script type="math/tex; mode=display">\begin{matrix}x = t_1(y,y^{'},...,y^{n})\\u = t_2(y,y^{'},...,y^{n})\end{matrix}</script><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例如一个常见的二自由度自行车模型，它的运动学模型和微分平坦模型的一般形式如下：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\dot x = vcos\theta \\\dot y = vsin\theta \\\dot \theta = \frac{vtan(\delta)}{L}\\\dot v = a_t \\k = \frac{tan(\delta)}{L} \\a_n = v^2\cdot k\end{matrix}\right.</script><ul><li>其中$(x,y,\theta)$是状态量，代表车体的位置和航向角</li><li>$(a_t,\delta)$是控制量，代表车的纵向加速度和前轮转角</li><li>$(k,a_n)$是曲率和向心加速度 </li></ul><p><strong>它的微分平坦模型如下：</strong></p><script type="math/tex; mode=display">\left\{\begin{array}{l}v=\eta\sqrt{\dot{x}^{2}+\dot{y}^{2}} \\\psi=arctan2(\eta\dot{y},\eta\dot{x}) \\a_{t}=\eta\frac{(\dot{x}\dot{x}+\dot{y}\dot{y})}{\sqrt{\dot{x}^{2}+\dot{y}^{2}}} \\\theta=arctan\mathrm{~}\eta L\frac{\dot{x}\ddot{y}-\dot{y}\ddot{x}}{(\dot{x}^{2}+\dot{y}^{2})^{\frac{3}{2}}} \\k=\eta\frac{\dot{x}\dot{y}-\dot{y}\ddot{x}}{(\dot{x}^{2}+y^{2})^{\frac{3}{2}}} \\a_{n}=\eta\frac{\dot{x}\dot{y}-\dot{y}\ddot{x}}{\sqrt{\dot{x}^{2}+\dot{y}^{2}}} \\\dot{\theta}=\eta L\frac{(\dot{x}\ddot{y}-\dot{y}\ddot{x})(\dot{x}^{2}+\dot{y}^{2})^{\frac{3}{2}}-3(\dot{x}\ddot{y}-\dot{y}\ddot{x})(\dot{x}^{2}+\dot{y}^{2})^{\frac{1}{2}}(\dot{x}\ddot{x}+\dot{y}\dot{y})}{(\dot{x}^{2}+\dot{y}^{2})^{3}+L^{2}(\dot{x}\ddot{y}-\dot{y}\dot{x})^{2}}\end{array}\right.</script><ul><li>其中$\eta \in {-1,1}$，-1表示车辆倒车运动，1表示前进行驶。<blockquote><p><a href="https://photin1a.github.io/2025/01/06/%E6%9B%B2%E7%8E%87%E7%9A%84%E5%AE%9A%E4%B9%89/">曲率的定义</a><br><a href="https://zhuanlan.zhihu.com/p/673869620">自行车微分平坦模型</a></p></blockquote></li></ul><hr><h1 id="1-BVP（Boundary-Value-Problem）"><a href="#1-BVP（Boundary-Value-Problem）" class="headerlink" title="1. BVP（Boundary Value Problem）"></a>1. BVP（Boundary Value Problem）</h1><p><strong>定义</strong>：最优控制中的边值问题（BVP）是指在给定初始和终止条件下，求解最优控制问题的控制策略和状态轨迹的一种方法。</p><blockquote><p><strong>BVP：</strong> 一个两点（起点、终点）状态已知，求中间最优序列的问题。  </p></blockquote><h2 id="1-1-最优性条件"><a href="#1-1-最优性条件" class="headerlink" title="1.1 最优性条件"></a>1.1 最优性条件</h2><script type="math/tex; mode=display">min\int_0^Tv(t)^TWv(t)dt</script><script type="math/tex; mode=display">s.t.  z^{s}(t)=v(t), \forall  t \in [0,T],</script><script type="math/tex; mode=display">z^{[s-1]}(t_0)=\bar z_{o},z^{[s-1]}(t_M)=\bar z_{f}.</script><p>对于以上 $minmum \ control$ 问题，若系统是<strong>微分平坦</strong>的，且最小控制量是平坦变量的 $s$ <strong>阶次导数</strong>，则 $BVP$问题的最优解是一个 $2s-1$ <strong>次多项式</strong>。<br><!-- ||$x$|$v$|$a$|$jerk$|$snap$|...||---|---|---|---|---|---|---||阶次$s$|0|1|2|3|4|...|$ploy\ 2s-1$|0|1|3|5|7|...|| --></p><h2 id="1-2-BVP"><a href="#1-2-BVP" class="headerlink" title="1.2 BVP"></a>1.2 BVP</h2><p>对于一个 $minJerk$ 问题，它的最优解是一个5次多项式，通过起点终点只有唯一解。</p><script type="math/tex; mode=display">\beta (t) = \mathbf{\lambda}_t^T\cdot\mathbf{c} = c_0+c_1t+c_2t^2+c_3t^3+c_4t^4+c_5t^5=[1\ t\ \ t^2\ t^3\ t^4\ t^5]\cdot[c_0\ c_1\ c_2\ c_3\ c_4\ c_5]^T</script><script type="math/tex; mode=display">\begin{bmatrix} \beta(0)\\ \beta^{'}(0)\\ \beta^{''}(0)\\ \beta(T)\\ \beta^{'}(T)\\ \beta^{''}(T)\end{bmatrix}=\begin{bmatrix}  \lambda_0^T\\  \lambda_0^{(1)T}\\  \lambda_0^{(2)T}\\  \lambda_T^T\\  \lambda_T^{(1)T}\\  \lambda_T^{(2)T}\end{bmatrix}\cdot \mathbf{c}=\begin{bmatrix}  1 &0 &0 &0 &0 &0\\  0 &1 &0 &0 &0 &0\\  0 &0 &2 &0 &0 &0\\  1 &T &T^2 &T^3 &T^4 &T^5\\  0 &1 &2T &3T^2 &4T^3 &5T^4\\  0 &0 &2 &6T &12T^2 &20T^3\end{bmatrix}\cdot \mathbf{c}=\begin{bmatrix}  x_0\\  v_0\\  a_0\\  x_T\\  v_T\\  a_T\\\end{bmatrix} \Longrightarrow A(0,T)\mathbf{c}=\mathbf{b}(0,T)</script><script type="math/tex; mode=display">\mathbf c = A^{-1}\cdot \mathbf{b}(0,T)</script><h1 id="2-BIVP（Boundary-Intermediate-Value-Problem）"><a href="#2-BIVP（Boundary-Intermediate-Value-Problem）" class="headerlink" title="2. BIVP（Boundary  Intermediate Value Problem）"></a>2. BIVP（Boundary  Intermediate Value Problem）</h1><blockquote><p><strong>BIVP：</strong> 一个两点（起点、终点）状态已知，中间 waypoints 已知，求中间最优轨线的问题。  </p></blockquote><h2 id="2-1-最优性条件"><a href="#2-1-最优性条件" class="headerlink" title="2.1 最优性条件"></a>2.1 最优性条件</h2><script type="math/tex; mode=display">min\int_{t_0}^{t_M}v(t)^TWv(t)dt</script><script type="math/tex; mode=display">s.t. \ \  \begin{aligned}  z^{s}(t)=v(t), \forall  t \in [t_0,t_M], \\ z^{[s-1]}(t_0)=\bar z_{o},z^{[s-1]}(t_M)=\bar z_{f},\\z^{[d_i-1]}(t_i)=\bar z_{i},\ 1 \le i \le M,\\t_{i-1} \le t_i, \ 1 \le i \le M.\end{aligned}</script><p>对于以上 $minmum \ control$ 问题，若系统是<strong>微分平坦</strong>的，且最小控制量是平坦变量的 $s$ <strong>阶次导数</strong>，则 $BIVP$问题的最优解的每一段都是一个 $2s-1$ <strong>次多项式</strong>,且具有大于 $s$ 阶的连续性。$minJerk$ 具有 $snap(4)$ 阶的连续性，$minSnap$具有 $pop(6)$ 阶的连续性</p><h2 id="2-2-BIVP"><a href="#2-2-BIVP" class="headerlink" title="2.2 BIVP"></a>2.2 BIVP</h2><p>对于 $minJerk$ 的BIVP问题。假设每段轨迹的时间 $T_i$ 已知，所有的waypoints状态已知，则waypoints和连续性约束可以表示为：</p><script type="math/tex; mode=display">\beta (t) = \mathbf{\lambda}_t^T\cdot\mathbf{c} = c_0+c_1t+c_2t^2+c_3t^3+c_4t^4+c_5t^5=[1\ t\ \ t^2\ t^3\ t^4\ t^5]\cdot[c_0\ c_1\ c_2\ c_3\ c_4\ c_5]^T</script><script type="math/tex; mode=display">\begin{bmatrix} \beta(t)\\ \beta^{'}(t)\\ \beta^{''}(t)\\ \beta^{'''}(t)\\ \beta^{''''}(t)\end{bmatrix}=\begin{bmatrix}  \lambda_t^T\\  \lambda_t^{(1)T}\\  \lambda_t^{(2)T}\\  \lambda_t^{(3)T}\\  \lambda_t^{(4)T}\end{bmatrix}\cdot \mathbf{c}=\begin{bmatrix}  1 &t &t^2 &t^3 &t^4 &t^5\\  0 &1 &2t &3t^2 &4t^3 &5t^4\\  0 &0 &2 &6t &12t^2 &20t^3\\  0 &0 &0 &6 &24t &60t^2\\  0 &0 &0 &0 &24 &120t\end{bmatrix}\cdot \mathbf{c} = \begin{bmatrix}  x(t)\\  v(t)\\  a(t)\\  jerk(t)\\  snap(t)\\\end{bmatrix}\Longrightarrow G(t)\mathbf{c}=\mathbf{b}(t)</script><script type="math/tex; mode=display">\begin{bmatrix}  \beta(T_i) &0\\  G(T_i) &-G(0)\end{bmatrix}\cdot \begin{bmatrix}  \mathbf{c}(i)\\  \mathbf{c}(i+1)\\\end{bmatrix}=\begin{bmatrix}  \mathbf{b}(T_i)\\  0\end{bmatrix}\Longrightarrow\begin{bmatrix}  E_i,F_i\end{bmatrix}\cdot \begin{bmatrix}  \mathbf{c}(i)\\  \mathbf{c}(i+1)\\\end{bmatrix}=\begin{bmatrix}  \mathbf{b}(i)\\  0\end{bmatrix}</script><p><strong>定理：设共有 $M$ 段轨迹 ${1,…,M}$，特别定义 $F_0=A(0)$ 和 $E_M=A(T_M)$ , $b_a,b_M$ 分别为起点、终点状态。BIVP最优解由以下线性方程组唯一确定。</strong></p><script type="math/tex; mode=display">M_{2Ms*2Ms}\mathbf{c}=b \Longrightarrow \left(\begin{array}{ccccc}\mathbf{F}_{0} & \mathbf{0} & \mathbf{0} & \cdots & \mathbf{0} \\\mathbf{E}_{1} & \mathbf{F}_{1} & \mathbf{0} & \cdots & \mathbf{0} \\\mathbf{0} & \mathbf{E}_{2} & \mathbf{F}_{2} & \cdots & \mathbf{0} \\\vdots & \vdots & \vdots & \ddots & \vdots \\\mathbf{0} & \mathbf{0} & \mathbf{0} & \cdots & \mathbf{F}_{M-1} \\\mathbf{0} & \mathbf{0} & \mathbf{0} & \cdots & \mathbf{E}_{M}\end{array}\right) \cdot \begin{bmatrix}  \mathbf{c}_1\\  \mathbf{c}_2\\  \mathbf{c}_3\\  \vdots\\  \mathbf{c}_{M-1}\\  \mathbf{c}_M\\\end{bmatrix}=\begin{bmatrix}  b_0\\  b(1)\\  0\\  \vdots\\  0\\  b_M\\\end{bmatrix}</script><p>拓展：对于三维或者多维平坦变量的参数化，满足 $M\cdot[\mathbf{c}_x,\mathbf{c}_y,\mathbf{c}_z]=[\mathbf{b}_x,\mathbf{b}_y,\mathbf{b}_z]$</p><h2 id="3-时空形变轨迹规划"><a href="#3-时空形变轨迹规划" class="headerlink" title="3. 时空形变轨迹规划"></a>3. 时空形变轨迹规划</h2><p><img src="/tra.png" alt=""></p><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>考虑一个更general的轨迹优化问题：</p><script type="math/tex; mode=display">  \begin{aligned}\min _{z(t),{T}} \int_{0}^{T} v(t)^{\mathrm{T}} \mathbf{W} v(t) \mathrm{d} t+\rho(T) \\\text { s. t. } z^{(s)}(t)=\bar{v}(t), \forall t \in[0, T] \text {, } \\\mathcal{G}\left(z(t), \cdots, z^{(s)}(t)\right) \preceq \mathbf{0}, \forall t \in[0, T] \text {, } \\z(t) \in\mathcal{F}, \forall t \in[0, T] \text {, } \\z^{[s-1]}(0)=\bar{z}_{o}, z^{[s-1]}(T)=\bar{z}_{f} \text {, } \\z^{[s-1]}:=\left(z^{\mathrm{T}}, \dot{z}^{\mathrm{T}}, \cdots, z^{(s-1)^{\mathrm{T}}}\right)^{\mathrm{T}} . \\\end{aligned}</script><p><strong>几个问题：</strong>   </p><ul><li>最优解的参数化形式是未知的。</li><li>space-time 增大了问题维度</li><li>动态可行性约束是非凸的</li><li>安全区域是高复杂度的  </li></ul><p><strong>可能的解决方法：</strong>   </p><ul><li>仍然使用参数化样条，虽然它可能不是最优的</li><li>仅仅优化空间，把时间分配固定下来</li><li>简化动力学，只考虑速度、加速度，不考虑角速度等底层的约束</li><li>尽量简化安全性约束，使得它是局部凸的</li></ul><h3 id="3-2-轨迹参数化"><a href="#3-2-轨迹参数化" class="headerlink" title="3.2 轨迹参数化"></a>3.2 轨迹参数化</h3><p>每段轨迹的 $T_i$ 未知，waypoints未知或部分已知，例如只知道 $(x,y)$ 。</p><script type="math/tex; mode=display">\begin{aligned}\min _{z(t), T} & \int_{0}^{T} v(t)^{\mathrm{T}} \mathbf{W} v(t) \mathrm{d} t+\rho(T), \\\text { s.t. } & v(t)=z^{(s)}(t), \forall t \in[0, T], \\& \mathcal{G}\left(z(t), \ldots, z^{(s)}(t)\right) \preceq \mathbf{0}, \forall t \in[0, T], \\& z(t) \in \mathcal{F}, \forall t \in[0, T], \\& z^{[s-1]}(0)=\bar{z}_{o}, z^{[s-1]}(T)=\bar{z}_{f}, \\& z^{[s-1]}=\left(z^{\mathrm{T}}, \dot{z}^{\mathrm{T}}, \ldots, z^{(s-1)^{\mathrm{T}}}\right)^{\mathrm{T}}\end{aligned}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-微分平坦&quot;&gt;&lt;a href=&quot;#0-微分平坦&quot; class=&quot;headerlink&quot; title=&quot;0. 微分平坦&quot;&gt;&lt;/a&gt;0. 微分平坦&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;</summary>
      
    
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/categories/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/tags/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>曲率的定义</title>
    <link href="https://photin1a.github.io/posts/41c0672e.html"/>
    <id>https://photin1a.github.io/posts/41c0672e.html</id>
    <published>2025-01-06T01:47:56.000Z</published>
    <updated>2025-01-06T01:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、曲率的定义"><a href="#1、曲率的定义" class="headerlink" title="1、曲率的定义"></a>1、曲率的定义</h1><p>曲率（Curvature）是描述曲线弯曲程度的量度。在二维空间中，对于一条曲线，曲率在某一点上可以通过以下公式计算：</p><script type="math/tex; mode=display">\kappa = \frac{d\theta}{ds}</script><p>其中：</p><ul><li><code>dθ</code>是曲线的切线方向（即车辆朝向）相对于路径切线的变化量。</li><li><code>ds</code>是路径上的微小弧长增量。</li></ul><h1 id="2、曲率的大小和方向"><a href="#2、曲率的大小和方向" class="headerlink" title="2、曲率的大小和方向"></a>2、曲率的大小和方向</h1><ul><li><strong>大小：</strong> 曲率的大小表示曲线弯曲的程度，曲线弯曲的越大，其曲率越大。</li><li><strong>方向：</strong> 曲率的正负决定了路径的弯曲方向。遵循<strong>右手定则</strong>，正曲率表示曲线逆时针弯曲，负曲率表示顺时针弯曲。</li></ul><h1 id="3、曲率的应用"><a href="#3、曲率的应用" class="headerlink" title="3、曲率的应用"></a>3、曲率的应用</h1><h2 id="3-1-曲率的计算"><a href="#3-1-曲率的计算" class="headerlink" title="3.1 曲率的计算"></a>3.1 曲率的计算</h2><p>在自动驾驶中，车辆的转弯半径受到前轮转角的限制，从而影响轨迹的曲率。现在有一条正曲率的轨迹，我们分情况讨论一下曲率：<br> <img src="./曲率.png" alt=""><br><strong>case 1.</strong> 一号车的方向是顺着轨迹的，想要跟踪这条轨迹只需要保持速度为正$v&gt;0$并向左打方向盘，$\delta&gt;0, tan(\delta)&gt;0$。轨迹曲率如下：</p><script type="math/tex; mode=display">\kappa = \frac{1}{R} = \frac{tan\delta}{L}</script><p><strong>case 2.</strong> 二号车的方向是相反轨迹的，想要跟踪这条轨迹则需要倒车，$v&lt;0$ 并向右打方向盘，$\delta&lt;0,tan(\delta)&lt;0$。轨迹曲率如下：</p><script type="math/tex; mode=display">\kappa = -\frac{tan\delta}{L}</script><p><strong>总结：</strong><br>综上，轨迹的曲率与车辆的运动关系可以表示为如下形式，$sign$ 是符号函数。</p><script type="math/tex; mode=display">\kappa = sign(v)\cdot \frac{tan\delta}{L}</script><blockquote><p>上述公式同样适用于其他非完整模型车辆</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、曲率的定义&quot;&gt;&lt;a href=&quot;#1、曲率的定义&quot; class=&quot;headerlink&quot; title=&quot;1、曲率的定义&quot;&gt;&lt;/a&gt;1、曲率的定义&lt;/h1&gt;&lt;p&gt;曲率（Curvature）是描述曲线弯曲程度的量度。在二维空间中，对于一条曲线，曲率在某一点上可以通</summary>
      
    
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/categories/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/tags/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
