<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Photinia</title>
  
  
  <link href="https://photin1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://photin1a.github.io/"/>
  <updated>2025-01-15T08:45:00.000Z</updated>
  <id>https://photin1a.github.io/</id>
  
  <author>
    <name>Photinia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录算法训练第八天|344反转字符串|541反转字符串II|卡码网-54替换数字</title>
    <link href="https://photin1a.github.io/posts/f6a04131.html"/>
    <id>https://photin1a.github.io/posts/f6a04131.html</id>
    <published>2025-01-15T08:45:00.000Z</published>
    <updated>2025-01-15T08:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、344反转字符串"><a href="#1、344反转字符串" class="headerlink" title="1、344反转字符串"></a>1、344反转字符串</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><ul><li>左右双指针</li></ul><p><strong>我的思路：</strong> 这道题很常规的问题，直接左右双指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = s[right];</span><br><span class="line">            s[right] = s[left];</span><br><span class="line">            s[left] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="2、541反转字符串II"><a href="#2、541反转字符串II" class="headerlink" title="2、541反转字符串II"></a>2、541反转字符串II</h1><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><ul><li>如果剩余字符少于 k 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</li></ul><p><strong>我的思路：</strong> 这道题和上一道题类似，都是反转字符串，只是这道题是分区域反转。直接使用左右双指针一个一个区域的反转就行。</p><p><strong>代码随想录：</strong> 直接用了for循环，非主要考察的部分可以直接用库函数，例如<code>reverse</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            right = right &lt; s.<span class="built_in">size</span>()?right:s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> i =left,j = right;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = s[j];</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">                s[i] = temp;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left = left<span class="number">+2</span>*k;</span><br><span class="line">            right = left+k<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3、卡码网-54替换数字"><a href="#3、卡码网-54替换数字" class="headerlink" title="3、卡码网-54替换数字"></a>3、卡码网-54替换数字</h1><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p><strong>我的思路：</strong> 我想的就是很简简单方法，直接依次遍历，遇到数字就换成<code>number</code>，结果用一个新字符串存储。<br><strong>代码随想录：</strong> 做到极致，不申请多余的临时变量。如果不申请临时的空间在原来的上面修改时会覆盖那些还没有遍历过的字符，<strong>核心还是解决覆盖问题。</strong> 在<code>88合并两个有序数组</code>中遇到过类似的做法，从后往前排就可以避免覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transNum</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=str[i]&amp;&amp; str[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            temp+=<span class="string">&quot;number&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp+=str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str = std::<span class="built_in">move</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    std::cin &gt;&gt; str;</span><br><span class="line">    <span class="built_in">transNum</span>(str);</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="type">int</span> sOldIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> sNewIndex = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从后往前将数字替换为&quot;number&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (sOldIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[sOldIndex] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                s[sNewIndex--] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[sNewIndex--] = s[sOldIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            sOldIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、344反转字符串&quot;&gt;&lt;a href=&quot;#1、344反转字符串&quot; class=&quot;headerlink&quot; title=&quot;1、344反转字符串&quot;&gt;&lt;/a&gt;1、344反转字符串&lt;/h1&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第七天|454四数相加II|383赎金信|15三数之和|18四数之和</title>
    <link href="https://photin1a.github.io/posts/3d015e1d.html"/>
    <id>https://photin1a.github.io/posts/3d015e1d.html</id>
    <published>2025-01-14T07:18:00.000Z</published>
    <updated>2025-01-15T14:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>tips：</strong> unordered_map用来存储数组（val，index）可以快速找到目标值的索引。</p><h1>1、454四数相加II</h1><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><ul><li>0 &lt;= i, j, k, l &lt; n</li><li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li></ul><p><strong>我的思路：</strong> 一开始我想的类似动态规划的思路一样，把从下往上一层一层的计算求和和数量，用HashMap存储，最后直接find查找，这样复杂度有点大。<br><strong>代码随想录：</strong> 他把上两行遍历求和统计在map中，下两行也遍历，遍历途中就直接find上两行的map里有没有合适的。而我是全部求出来。<code>1两数之和</code>也是类似思路。</p><ul><li><strong>多层迭代分解成多个子问题</strong>，这样比全部一起迭代快，全部一起迭代是n^4，但是分解为上下两部分时2*n^2。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mapi,mapj,mapk,mapl; <span class="comment">//val idx</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mapl[nums4[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l:mapl)&#123;</span><br><span class="line">                mapk[nums3[i]+l.first]+=l.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k:mapk)&#123;</span><br><span class="line">                mapj[nums2[i]+k.first]+=k.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ii:mapj)&#123;</span><br><span class="line">                mapi[nums1[i]+ii.first]+=ii.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapi[<span class="number">0</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map; <span class="comment">//val idx</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            map[nums1[i]+nums2[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(-nums3[i]-nums4[j]);</span><br><span class="line">            <span class="keyword">if</span>(it!=map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                len+=it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、383赎金信</h1><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p><strong>我的思路：</strong> ：这道题之前遇到过类似的<code>242有效的字母异位词</code>，按照我常规的思路就是直接两个数组都用Hashmap把元素和出现的次数存起来，然后两个map作比较看看他们的数量是否均等。但是在<code>代码随想录-242有效的字母异位词</code>学到了新思路，就是统计字符串1在map中，然后遍历字符串2，每遍历一次对应的map中的对应字符的数量-1，最后map中全为0则符合题意。<br><strong>代码随想录：</strong> ：和我说的方法一样。与之不同的是，他用一个数组来代替HashMap，因为<strong>题目说字符都是小写英文，所以是有限的，用数组足够</strong>，注意看题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; ran,mag;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;ransomNote.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ran[ransomNote[i]]++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;magazine.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ran[magazine[i]]!=<span class="number">0</span>)&#123;</span><br><span class="line">                ran[magazine[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:ran)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 通过record数据记录 magazine里各个字符出现次数</span></span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span></span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span></span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、15三数之和</h1><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p><p><strong>常用Tips：</strong> 把数组先排序，再处理。</p><p><strong>我的思路：</strong> 这道题耗费很长时间没做出来。这道题应该是<code>1两数之和</code>的加强版，首先都是在一个数组上寻找两个或多个值之和等于target的元素。我的思考是需要保证搜索时多个数的索引不能出现交叉，比如i=10，那就要一只在0~i之间，k就要在0~j之间。不然就会出现重复搜索，加慢速度。</p><ul><li><strong>怎么保证搜索过三个元素值的不在重复？</strong><br><strong>我的思考：</strong> 三个数不能出现重复的，比如{1,2,5}和{5,2,1}就重复了。<strong>问题是有没有什么机制找出他们的共性？？<strong>晕了一下我脑子里出现了一些操作，比如</strong>排序之后它两每个元素就都相同</strong>，不知道是什么时候刷题刷出这个感觉。但是如果用<code>HashMap</code>的话，这是三个元素没法放在键值里，必须自己重写Hash函数。于是由于我之前看<code>Apollo</code>的代码在写<code>A*</code>算法时用到了将<strong>下标转为字符串</strong>的做法，我也就萌生了这个想法。</li></ul><p><strong>我写的：</strong>  只通过了309/313个数据，其他的超时。可能是使用string做Hash键的原因。</p><p><strong><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>：</strong> 两层for循环就可以确定 两个数值，可以使用哈希法来确定 第三个数 0-(a+b) 或者 0 - (a + c) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。其他思路比较好的思路是先<strong>排序，再双指针搜索</strong>。</p><p><strong>思考：</strong> 在<code>1两数之和</code>中用了一层for循环，第二个数用HashMap确定，这道题我一开始想其他的牛b方法，硬是想不到。最后我还是前两个数用for循环，最后一个数用HashMap。但是看了代码随想录之后有了些反思：<strong><font color='red'>很多时候解题并不需要什么NB的方法，只是我过分追求于完美导致了最后首尾难顾，时间也过去了。谨记：追求完美，面面俱到，很难成功！！</font></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; maps;</span><br><span class="line">        std::unordered_set&lt;string&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = maps.<span class="built_in">find</span>(-nums[i]-nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(it!=maps.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k:it-&gt;second)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(k&lt;j)&#123;</span><br><span class="line">                            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(&#123;nums[i],nums[j],nums[k]&#125;)</span></span>;</span><br><span class="line">                            <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">                            <span class="keyword">auto</span> str = <span class="built_in">to_string</span>(temp[<span class="number">0</span>])+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(temp[<span class="number">1</span>])+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(temp[<span class="number">2</span>]);</span><br><span class="line">                            <span class="keyword">if</span>(res.<span class="built_in">find</span>(str)==res.<span class="built_in">end</span>())&#123;</span><br><span class="line">                                re.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[j],nums[k]&#125;));</span><br><span class="line">                            &#125;</span><br><span class="line">                            res.<span class="built_in">emplace</span>(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了代码随想录的视频后我写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            left = i<span class="number">+1</span>;</span><br><span class="line">            right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">continue</span>; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;  <span class="comment">//剪枝</span></span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left!=i<span class="number">+1</span> &amp;&amp; nums[left]==nums[left<span class="number">-1</span>])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  <span class="comment">//剪枝</span></span><br><span class="line">                <span class="keyword">if</span>(right!=nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[right]==nums[right<span class="number">+1</span>])&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  <span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[left]+nums[right]-target==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[left],nums[right]&#125;));</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]-target&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]-target&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leetcode 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4、18四数之和</h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p><strong>我的思路：</strong> 这道题三数之和的进阶版。我的思路是前两个数嵌套for循环，后两个数用双指针。<br><strong>遇到的几个坑，折腾了好久：</strong></p><ul><li><code>for(int i = 0;i&lt; nums.size()-3;i++)</code>这句代码中num.size()返回的是size_t(long unsigned int)无符号类型，所以-3之后如果是负数会转换为极大的正数。一直循环。。正确的做法<code>for(int i = 0;i&lt; (int)nums.size()-3;i++)</code>。</li><li><code>if(nums[i]&gt;target)continue;</code> 剪枝只有在<code>target=0</code>时才有效。替换为<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code></li></ul><p><strong><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// if(nums[i]&gt;target)continue; //剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;  <span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>;j&lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>()<span class="number">-2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i<span class="number">+1</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>])<span class="keyword">continue</span>;  <span class="comment">//剪枝</span></span><br><span class="line">                left = j<span class="number">+1</span>;</span><br><span class="line">                right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="type">long</span> target1 = (<span class="type">long</span>)target-nums[i]-nums[j];</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(left!=j<span class="number">+1</span> &amp;&amp; nums[left]==nums[left<span class="number">-1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;  <span class="comment">//剪枝</span></span><br><span class="line">                    <span class="keyword">if</span>(right!=nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[right]==nums[right<span class="number">+1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;  <span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(nums[left]+nums[right]==target1)&#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[j],nums[left],nums[right]&#125;));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[left]+nums[right]-target1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[left]+nums[right]-target1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt; unordered_map用来存储数组（val，index）可以快速找到目标值的索引。&lt;/p&gt;
&lt;h1&gt;1、454四数相加II&lt;/h1&gt;
&lt;p&gt;给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第六天|哈希表理论基础|242有效的字母异位词|349两个数组的交集|202快乐数|1两数之和</title>
    <link href="https://photin1a.github.io/posts/5f4e67ee.html"/>
    <id>https://photin1a.github.io/posts/5f4e67ee.html</id>
    <published>2025-01-13T07:15:00.000Z</published>
    <updated>2025-01-13T07:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>哈希表理论基础</h1><h2 id="什么时候用哈希法？">什么时候用哈希法？</h2><p>当我们遇到了要<strong>快速判断一个元素是否出现集合里</strong>的时候，就要考虑哈希法。</p><h2 id="Hash表">Hash表</h2><p>数组就是一张哈希表。我们通过Hash函数把<code>键</code>映射成一个整数值，然后通过取模操作映射到哈希表的索引上。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt=""><br>但是可能出现多个键都映射到同一个索引上，这个现象叫<strong>哈希碰撞</strong>。解决这个问题有两个方案，一个是<strong>拉链法</strong>，一个是<strong>线性探测法</strong>。</p><table>  <tr>    <td><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png" alt="拉链法" width="100%" height="200"></td>    <td><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png" alt="线性探测法" width="100%" height="200"></td>  </tr></table><h2 id="常见的三种Hash结构">常见的三种Hash结构</h2><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>数组就没啥可说的了。在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p><code>std::unordered_set</code>底层实现为哈希表，<code>std::set</code> 和<code>std::multiset</code> 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th>映射</th><th>实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p><code>std::unordered_map</code> 底层实现为哈希表，<code>std::map</code> 和<code>std::multimap</code> 的底层实现是红黑树。同理，<code>std::map</code> 和<code>std::multimap</code> 的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><h1>1、242有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br><strong>我的思路：</strong> 异位词指的就是两个字符串中每个字符出现的次数是相同的。我可以用两个unordered_map统计他们出现的次数，然后比较是否相等。</p><p><strong><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#%E6%80%9D%E8%B7%AF">代码随想录</a>：</strong> 这里比较巧妙，他只用一个map去存第一个字符串的元素出现次数。然后去第二个字符串上去遍历，每统计到一个元素就-1，这样如果map所有值都为0就说明两个字符串是异位词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=t.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map1,map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            map1[s[i]]++;</span><br><span class="line">            map2[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]]!=map2[s[i]])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、349两个数组的交集</h1><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集。输出结果中的每个元素一定是唯一 的。我们可以 不考虑输出结果的顺序 。</p><blockquote><p><strong>tips:</strong> 不涉及到排序问题就用<code>Hash容器</code>。这里关键在于只用统计元素是否出现，不用统计他们出现的次数。所以使用<code>unordered_set</code>更好，若是涉及次数的使用<code>unordered_map</code>。</p></blockquote><p><strong>我的思路：</strong> 直接用unordered_set统计两个数组出现的元素，然后比较哪些一样。<br><strong>代码随想录：</strong> 用了很多的小tips，例如容器支持迭代器初始化，不用一个一个的放进去。见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; inter;</span><br><span class="line">        std::unordered_set&lt;<span class="type">int</span>&gt; set1,set2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            set<span class="number">1.</span><span class="built_in">emplace</span>(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            set<span class="number">2.</span><span class="built_in">emplace</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:set1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set<span class="number">2.</span><span class="built_in">count</span>(s)!=<span class="number">0</span>)&#123;</span><br><span class="line">                inter.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums<span class="number">1.</span>begin(), nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、202快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。「快乐数」 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li><li>如果这个过程 结果为 1，那么这个数就是快乐数。</li><li>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</li></ul><p><strong>我的思路：</strong> ：这道题我的第一感觉是快乐数好像没啥特殊性质可以简化迭代，只有一直判断下去到最后才知道是不是快乐数。最后等于1那就是快乐数，最后一直循环了那就不是快乐数。我用一个<code>unordered_set</code>存储出现过的元素，每次生成新元素就进行判断看它是否再集合里，如果在则循环就不是快乐数。<br><em><strong>如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></em> 代码随想录的方法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        std::unordered_set&lt;<span class="type">int</span>&gt; his;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(his.<span class="built_in">find</span>(n)==his.<span class="built_in">end</span>())&#123; <span class="comment">// 循环条件：没有出现过</span></span><br><span class="line">            his.<span class="built_in">emplace</span>(n); <span class="comment">// 存储出现过的元素</span></span><br><span class="line">            <span class="keyword">auto</span> str_n = std::<span class="built_in">to_string</span>(n);</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str_n.<span class="built_in">size</span>())&#123;</span><br><span class="line">                n+=std::<span class="built_in">pow</span>((str_n[i]-<span class="string">&#x27;0&#x27;</span>),<span class="number">2</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码随想录</span></span><br><span class="line"><span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123; <span class="comment">//一直取余</span></span><br><span class="line">        sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4、1两数之和</h1><p><strong>我的思路：</strong> ：这道题我想的还是遍历的思想，看快指针之前的元素能不能有和他成对儿的。复杂度是 O(n*n)。<br><strong><a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></strong> ：使用一个Hashmap去存出现过的元素和它的索引，在迭代的过程中不断判断是否有元素可以和当前元素成对儿。<strong>这个map和我的内层for循环是一样的作用，但是却可以以O(1)的复杂度找到目标。</strong></p><p><strong>总结tips：</strong> <font color='red'> 如果你要用循环去找一个数，而这个循环中的大部分元素总是被重复操作，可以考虑使用HashMap。 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;i;j++)&#123;  <span class="comment">// O(n)</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; re = &#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> re;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码随想录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = maps.<span class="built_in">find</span>(target - nums[i]);  <span class="comment">// O(1)</span></span><br><span class="line">            <span class="keyword">if</span>(it!=maps.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;i,it-&gt;second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            maps.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;哈希表理论基础&lt;/h1&gt;
&lt;h2 id=&quot;什么时候用哈希法？&quot;&gt;什么时候用哈希法？&lt;/h2&gt;
&lt;p&gt;当我们遇到了要&lt;strong&gt;快速判断一个元素是否出现集合里&lt;/strong&gt;的时候，就要考虑哈希法。&lt;/p&gt;
&lt;h2 id=&quot;Hash表&quot;&gt;Hash表&lt;/h2&gt;
&lt;p&gt;数</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode面试经典150道</title>
    <link href="https://photin1a.github.io/posts/1b084fc8.html"/>
    <id>https://photin1a.github.io/posts/1b084fc8.html</id>
    <published>2025-01-12T14:50:00.000Z</published>
    <updated>2025-01-12T14:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>2025.1.12</h1><h2 id="88-合并两个有序数组">88. 合并两个有序数组</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><ul><li>双指针</li></ul><p><strong>我的解题思路</strong> ：题目要求合并后的数组仍然放在nums1上，与<code>合并两个有序链表</code>不同的是，<strong>数组的当前位置存储最大值时会覆盖原来的元素</strong>，而链表不会，因为链表可以断开再连。我使用的方法是创建数组存储合并后的数据，最后移动语义到nums1上。<br><strong>其他思路</strong> ：看了官方的另外一种解题思路很巧妙。<strong>直接从后往前排序，这样就不用担心元素覆盖的问题</strong>，因为本来后面就没元素（或者说都是零）。更巧妙的是，从后往前排时数组1后面剩余的空位置永远够排序，根本不用担心排到最后会覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(m+n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,cur = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; m &amp;&amp; p2 &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                nums[cur] = nums1[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[cur] = nums2[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == m)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2&lt;n)&#123;</span><br><span class="line">                nums[cur++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p1&lt;m)&#123;</span><br><span class="line">                nums[cur++] = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 官方在这里使用for循环重新赋值了一下。由于时c++我可以用移动语义。</span></span><br><span class="line">        nums1 = std::<span class="built_in">move</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode官方的解法3 逆向双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode官方的解法1 </span></span><br><span class="line"><span class="comment">// 先把nums2复制在nums1后面，然后调用sort()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="27-移除元素">27. 移除元素</h2><p><strong>我的思路：</strong> 简单。快指针在前面探路找不同与val的值，慢指针在后面赋值。</p><ul><li>快慢双指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h2><p><strong>我的思路：</strong> 简单。快指针在前面探路找不同与val的值，慢指针在后面赋值。关键在于那个值是之前没出现过的值，所以需要个map或者数组记录一下之前出现过哪些值，出现了几次。这里要注意使用<code>map[]</code>索引是如果不存在该元素，则会常见一个默认值为0的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, low = <span class="number">0</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[nums[fast]] &lt; <span class="number">1</span>)&#123;   <span class="comment">//不允许重复元素</span></span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[fast]]++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="80-删除有序数组中的重复项-II">80. 删除有序数组中的重复项 II</h2><p><strong>我的思路：</strong> 和<code>26. 删除有序数组中的重复项</code>类似，只是题目改了允许重复一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, low = <span class="number">0</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[nums[fast]] &lt; <span class="number">2</span>)&#123;    <span class="comment">//允许重复一个元素</span></span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[nums[fast]]++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="169-多数元素">169. 多数元素</h2><p>多数元素：返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。<br><strong>我的思路：</strong> 多数元素其实就是出现次数最多的元素并且次数<code>&gt;n/2</code>，题目说一定有多数元素，所以直接找最多的元素就行。首先要用一个<code>unordered_map</code>或者数组记录各个元素出现的次数。有两个思路，第一个就是记录的过程中就不断的去比较谁次数多，保留最多的那个。第二种就是先记录，最后再找最大值。</p><p><strong>leetcode：</strong> :上面我的思路是找出现次数最多的元素，但是<strong>针对于多数元素的特殊性质，把元素排序，那么多数元素n/2的位置一定有。</strong> 这样就解决了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="type">int</span> item = nums[<span class="number">0</span>],maxsize = <span class="number">1</span>;</span><br><span class="line">        maps[item]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            maps[nums[i]]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( maps[nums[i]]&gt;maxsize)&#123;</span><br><span class="line">                maxsize = maps[nums[i]];</span><br><span class="line">                item = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            maps[nums[i]]++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> com = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;left,<span class="type">const</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 别用std::max函数</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max_element</span>(maps.<span class="built_in">begin</span>(),maps.<span class="built_in">end</span>(),com)-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1>2025.1.13</h1>]]></content>
    
    
    <summary type="html">为了offer而战</summary>
    
    
    
    <category term="LeetCode面试经典150道" scheme="https://photin1a.github.io/categories/LeetCode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%81%93/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Failed to connect to github.com port 443 after 21150 ms, Could not connect to server</title>
    <link href="https://photin1a.github.io/posts/d1a2de71.html"/>
    <id>https://photin1a.github.io/posts/d1a2de71.html</id>
    <published>2025-01-11T15:25:00.000Z</published>
    <updated>2025-01-11T15:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Failed to connect to <a href="http://github.com">github.com</a> port 443 after 21150 ms: Could not connect to server</h1><p><strong>什么是443端口号？</strong><br><strong>443端口是互联网上所有加密通信的通用端口，也是HTTPS所使用的端口号。</strong> <strong>HTTP 协议使用的是80端口</strong>处理所有入站和出站信息。但问题是 HTTP 协议不安全，因为所有数据都以纯文本形式从一台计算机传输到另一台计算机。</p><p><strong>你的梯子使用的是什么端口号？</strong><br>我的梯子是通过本地127.0.0.1:7890向代理服务器发送请求。也就是说，<strong>我如果想用梯子，我就得用7890端口向外部请求网络服务。</strong></p><hr><p><strong>问题：</strong><br>一般你用梯子设置代理ip端口之后，浏览器就会使用你设置的ip端口。但是git他却没有使用代理端口7890给我传东西，而是继续使用默认的443告诉我超时。<br><strong>解决：</strong><br>我们需要设置git的代理端口也为7890.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 方法1（不推荐）：全局设置，针对所有的git访问网址都代理</span></span><br><span class="line"><span class="comment">#使用http代理 </span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br><span class="line"><span class="comment">#使用socks5代理</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment">##方法2（推荐）：只对github代理，github只是用http</span></span><br><span class="line"><span class="comment">#使用socks5代理（推荐）</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:7890</span><br><span class="line"><span class="comment">#使用http代理（不推荐）</span></span><br><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p><strong>查询代理：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure><p><strong>取消代理：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">解决 git push 失败的问题</summary>
    
    
    
    <category term="疑难杂症" scheme="https://photin1a.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第四天|24两两交换链表中的节点|19删除链表的倒数第N个节点|面试题02.07链表相交|142环形链表II</title>
    <link href="https://photin1a.github.io/posts/8e38590b.html"/>
    <id>https://photin1a.github.io/posts/8e38590b.html</id>
    <published>2025-01-11T06:00:00.000Z</published>
    <updated>2025-01-11T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、24两两交换链表中的节点</h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p><blockquote><p><a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></blockquote><p>思路：拿到这道题看到时看到两两交换节点，就想到能不能用双指针，但是对于什么时候用双指针还是有点迷糊的。然后思考能不能用虚拟头节点，思考了以下我只是两两交换节点似乎不和虚拟头节点沾边，我没法用上。写着写着发现我把这两个节点交换时，好像涉及到要把之前的节点连上，把之后的节点连上，之后的节点可以使用cur指针找到，但是之前的节点没法啊。。。于是恍然大悟。.</p><p><strong>虚拟头节点、双指针总结：</strong> 在处理需要断键重连的链表问题时，如果一下子想不出来，<strong>优先思考可不可以用双指针</strong>，双指针第一个指针存储last节点，另一个则是cur节点，可以省去很多临时节点。如果第一个元素也需要处理，那就需要前面加上虚拟头节点，方便<strong>第一个元素也可以有last</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pre = &amp;dumy, *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = cur-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next-&gt;next = cur;</span><br><span class="line">        cur-&gt;next = tmp; </span><br><span class="line"></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了代码随想录之后看到他是直接用了一个指针，从虚拟头节点就开始，这样之后的节点就可以直接next.next…下去。我用双指针的话有last访问之前的节点。<br><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// 步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// 步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* result = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>2、19删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt=""></p><blockquote><p><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></blockquote><p><strong>思路：</strong> 这题之前看labuladong的博客时刷过，有两种方法：第一种时很直接的，先遍历一遍算出链表总长度l，然后l-n就是需要移除的下标，我们需要找到下标l-n-1的元素就可以移除l-n。第二种是用<strong>快慢双指针</strong>，快指针先走n步，然后慢指针才开始走，快指针走到头了慢指针对应的元素就是要移除的元素。这两种算法其实复杂度一样，但是双指针的显得更nb。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line">  ListNode *p = &amp;dumy;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  p =  &amp;dumy;</span><br><span class="line">  <span class="type">int</span> idx = i-n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(idx--)&#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快慢双指针做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line">    ListNode *fast = &amp;dumy, *low = &amp;dumy;</span><br><span class="line">    <span class="type">int</span> i = n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    low-&gt;next = low-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3、面试题02.07链表相交</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目数据 保证 整个链式结构中不存在环。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt=""></p><blockquote><p><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></blockquote><p><strong>思路：</strong> 这道题刷过，思路有两个。一是先遍历求各自的长度，然后长的先移动对其短的。另一种是同时遍历A、B链表，哪个遍历完就遍历下一个，这样就能保证两个遍历的一样多，直到遇上相同节点就结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = headA,*p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span> &amp;&amp; p2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4、142环形链表II</h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><blockquote><p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></blockquote><p><strong>思路：</strong> 这道题是判断链表是否有环，有则返回环点。之前刷过，思路上快慢双指针，快指针以两倍速走，慢指针一倍速走，如果有环则快指针早晚追上慢指针，如果没环最后会遇到<code>nullptr</code>。有一个注意的是：快慢指针相遇的位置并不一定是环点。我的思路是先找到相遇点，然后展开成两个链表相遇的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle1</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dumy</span><span class="params">(<span class="number">0</span>,head)</span></span>;</span><br><span class="line">        ListNode *low = &amp;dumy,*fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(low == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB, ListNode *inse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *end = inse-&gt;next;</span><br><span class="line">        ListNode *p1 = headA,*p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p1 == end &amp;&amp; p2 == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p1 == end)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2 == end)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> inse = <span class="built_in">detectCycle1</span>(head);</span><br><span class="line">        <span class="keyword">if</span>(inse == <span class="literal">nullptr</span>) <span class="keyword">return</span> inse;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getIntersectionNode</span>(head,inse-&gt;next,inse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了<a href="https://www.bilibili.com/video/BV1q94y1X7vy/?spm_id_from=333.999.0.0&amp;vd_source=d83fadd3138d002993b778881de0f2e9">labuladong视频</a>和<a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF">文章</a>之后我悟了。他的做法也是先找环内点，然后双指针一个从头，一个从环内点开始，遇到的就是环起点。<br><img src="https://labuladong.online/algo/images/linked-two-pointer/3.jpeg" alt=""><br><img src="https://labuladong.online/algo/images/linked-two-pointer/2.jpeg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、24两两交换链表中的节点&lt;/h1&gt;
&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode.com/uplo</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第三天|链表理论|203移出链表元素|707设计链表|206翻转链表</title>
    <link href="https://photin1a.github.io/posts/c83e90c7.html"/>
    <id>https://photin1a.github.io/posts/c83e90c7.html</id>
    <published>2025-01-10T11:30:00.000Z</published>
    <updated>2025-01-10T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>单链表：</strong> 指针域只能指向节点的下一个节点。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt=""></p></li><li><p><strong>双链表：</strong> 每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表 既可以向前查询也可以向后查询。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt=""></p></li><li><p><strong>循环链表：</strong> 就是链表首尾相连。循环链表可以用来解决约瑟夫环问题。<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png" alt=""></p></li><li><p>数组的元素是不能删的，只能覆盖。双链表 既可以向前查询也可以向后查询。</p></li></ul><hr><h1>1、203移出链表元素</h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。<br><strong>思路</strong> ：这道题一开始我以为简单，就是简单的链表遍历。但是我忽略了一个小细节，导致卡了一会，就是<strong>只有当下一个节点值不是要求移出的值时才步进指针，因为是要求值的时候我们断键重连后其实节点已经更新了，下一个节点应该再次被检查，不能步进指针</strong>。<br>**知识点：**虚拟头结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dumy = <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)&#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dumy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2、 707设计链表</h1><p><strong>思路：</strong> 拿到这道题，一开始想的还是用单链表的遍历，这样每一个函数就都能写了。但是测试了运行13ms，击败42%的人，写的不是很好。估计得掌握双链表才能更快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    ListNode dumy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;next-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        dumy.next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,dumy.next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ == index)&#123;</span><br><span class="line">                cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,cur-&gt;next);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == index)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val,cur-&gt;next);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *cur = &amp;dumy;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ == index)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>3、206反转链表</h1><blockquote><p><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a><br>没写出来，,，没往双指针上去想。。。。。。。看了代码随想录之后感觉思路好清晰<br><img src="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt=""></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp; <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            temp = cur-&gt;next;  <span class="comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">// 翻转操作</span></span><br><span class="line">            <span class="comment">// 更新pre 和 cur指针</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head, ListNode *tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tail-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(head-&gt;next,tail);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail = <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="built_in">traverse</span>(head,&amp;tail);</span><br><span class="line">        <span class="keyword">return</span> tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单链表：&lt;/strong&gt; 指针域只能指向节点的下一个节点。&lt;br&gt;
&lt;img src=&quot;https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第二天|209长度最小的子数组|59螺旋矩阵II|977有序数组的平方|区间和、前缀和|开发商购买土地</title>
    <link href="https://photin1a.github.io/posts/f75317da.html"/>
    <id>https://photin1a.github.io/posts/f75317da.html</id>
    <published>2025-01-09T12:00:00.000Z</published>
    <updated>2025-01-09T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>0. 知识点</h1><ul><li>滑动窗口</li><li>前缀和数组</li></ul><h2 id="滑动窗口算法（快慢指针）">滑动窗口算法（快慢指针）</h2><ul><li>滑动窗口算法技巧主要用来解决<strong>子数组、子串</strong>问题，比如让你寻找符合某个条件的最长/最短子数组。</li><li>它是一个左闭右开的区间</li><li>时间复杂度O(N)<br>思路：先移动右指针找到可行解，然后移动左指针找到最优解。然后再移动有指针。。。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    <span class="keyword">auto</span> window = ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c);</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和数组、矩阵">前缀和数组、矩阵</h2><h3 id="数组">数组</h3><p><a href="https://labuladong.online/algo/data-structure/prefix-sum/">lanuladong</a><br><img src="https://labuladong.online/algo/images/difference/1.jpeg" alt="前缀和数组创建"><br>求索引区间 <code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1]</code> 得出。</p><h3 id="矩阵">矩阵</h3><p><img src="https://labuladong.online/algo/images/presum/5.jpeg" alt=""><br>维护和数组类似，对于m*n的矩阵，我们维护一个m+1*n+1的前缀和矩阵。<code>preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1]</code>。</p><hr><h2 id="总结：">总结：</h2><p>学习时长：四个半小时。映像比较深刻的就是左闭右开很多时候会减少计算量。</p><h1>1、209长度最小的子数组</h1><blockquote><p><a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">labuladong文章链接</a><br><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录文章链接</a><br><a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">视频链接</a><br>知识点：滑动窗口</p></blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其总和大于等于 target 的长度最小的子数组[numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p><strong>思路：</strong> 拿到这道题首先看到是找<strong>最小串问题，优先考虑滑动窗口法</strong>。滑动窗口法的思路是<strong>先移动右指针找到可行解，然后移动左指针找到最优解</strong>。这里可行解是满足其总和大于等于 target，最优解是可行解中的最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">//初始时区间内没有数据，所以是左闭右开的区间</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minlen = std::<span class="built_in">numeric_limits</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右指针</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        sum+=nums[right]; <span class="comment">// 移入窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、移动右指针找到可行解，可行解的条件就是sum &gt;= target</span></span><br><span class="line">        <span class="comment">// 然后开始移动左指针</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="comment">// 2、移动左指针找到最优解，移出窗口</span></span><br><span class="line">            <span class="type">int</span> len = right-left;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;minlen)&#123;</span><br><span class="line">                minlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            sum-=nums[left]; </span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minlen==std::<span class="built_in">numeric_limits</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">max</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> minlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2、59螺旋矩阵II</h1><blockquote><p><a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">labuladong文章链接</a><br><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录文章链接</a><br><a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">视频链接</a><br>知识点：滑动窗口</p></blockquote><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p><strong>我的思路</strong>：拿到这一题我首先想到的就是按照题目所说的一圈一圈的填充矩阵。除此之外我再也想不到了。。。好好复盘了一下之前做的那些题，<strong>没做出来的原因并不是这些框架不会，而是没想出来怎么把这些题抽象成框架出来</strong>。。图穷匕见了，还是刷的少了。看了代码随想录之后我发现思路和我是一样的，但是在处理转圈问题上我做题时不够清晰，而且缺乏技巧，他是叠加一个一个的转圈，xy滚动叠加，而我每次重新计算,思路上比我得容易理解很多。还是刷的少了。<br>按照以上思路的暴力算法：击败6.74%的人，可怜。。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=n<span class="number">-2</span>-i;j++)&#123;</span><br><span class="line">            mat[i][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=n<span class="number">-2</span>-i;j++)&#123;</span><br><span class="line">            mat[j][n<span class="number">-1</span>-i]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>-i;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[n<span class="number">-1</span>-i][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>-i;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[j][i]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        mat[n/<span class="number">2</span>][n/<span class="number">2</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新优化后好了很多，，但是<strong>我发现一般对于边界取不到优先使用左闭右开的区间会省去很多计算量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k = n<span class="number">-1</span>-i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            mat[i][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            mat[j][k]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[k][j]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k;j&gt;=i<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            mat[j][i]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        mat[n/<span class="number">2</span>][n/<span class="number">2</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了代码随想录的视频<strong>左闭右开</strong>：重新做了大幅提升速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>;start&lt;n/<span class="number">2</span>;start++)&#123;</span><br><span class="line">        <span class="type">int</span> x = start;</span><br><span class="line">        <span class="type">int</span> y = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;y&lt;n-start<span class="number">-1</span>;y++)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;n-start<span class="number">-1</span>;x++)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;y&gt;start;y--)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;x&gt;start;x--)&#123;</span><br><span class="line">            mat[x][y]=data++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        mat[n/<span class="number">2</span>][n/<span class="number">2</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;0. 知识点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口&lt;/li&gt;
&lt;li&gt;前缀和数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;滑动窗口算法（快慢指针）&quot;&gt;滑动窗口算法（快慢指针）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口算法技巧主要用来解决&lt;strong&gt;子数组、子串&lt;/stron</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练第一天|数组理论|704二分查找|24移除元素|977有序数组的平方</title>
    <link href="https://photin1a.github.io/posts/22bb52a8.html"/>
    <id>https://photin1a.github.io/posts/22bb52a8.html</id>
    <published>2025-01-08T10:07:00.000Z</published>
    <updated>2025-01-08T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>0、tips</h1><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的</li><li>数组的元素是不能删的，只能覆盖。</li></ul><h2 id="总结：">总结：</h2><p>学习时长：三小时。今天的题都是比较基础的，直接运用算法框架就能写，977有序数组题没看仔细平方卡了一下。前面花时间右总结了一下二分法的框架和细节。</p><h1>1、704二分查找</h1><blockquote><p><a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">labuladong文章链接</a><br><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">代码随想录文章链接</a><br><a href="https://www.bilibili.com/video/BV1fA4y1o715">视频链接</a></p></blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li>拿到这道排序题，首先看到是对有序数组查找一个数，可以使用二分查找，复杂度OlogN。对于二分查找有三种类型：查找一个数、查找左侧边界、查找右侧边界，每一种都可以用左闭右闭和左闭右开的方法去索引。</li></ul><p><strong>这里我掌握左闭右闭的二分框架。</strong></p><ul><li>思路：<ul><li>首先明确我使用左闭右闭的框架，即左右双指针都是即将搜索的区间边界。得到初始条件<code>int left = 0, right = nums.size()-1</code></li><li>然后明确循环条件，搜索有效的条件应该是左右边界重合。得到<code>left &lt;= right</code></li><li>最后保证每次循环更新的左右双指针都左闭右闭</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在框架中<code>mid = left + (right - left) / 2</code>和<code>(right + left)/2</code>结果相同，但是可以有效防止<code>left</code>和<code>right</code>太大，直接相加导致溢出的情况。</p></blockquote><p><strong>左闭右开：</strong></p><ul><li>思路：<ul><li>首先明确使用左闭右开的框架，即左指针是即将搜索的左区间边界，右指针是即将搜索的右区间边界+1。得到初始条件<code>int left = 0, right = nums.size()</code></li><li>然后明确循环条件，搜索有效的条件应该是左右边界重合。由于右指针是开区间，它的前一个才是右边界。得到<code>left &lt; right</code></li><li>最后保证每次循环更新的左右双指针都左闭右开</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid<span class="number">+1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2、27移除元素</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。<br>思路：快慢双指针解法，复杂度O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">            nums[low] = nums[fast];</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3、977有序数组的平方</h1><p>给你一个按非递减顺序排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按非递减顺序排序。</p><p>首先拿到这一题，最先想到的是先平方，再排序，鉴于不怎么会排序算法就没继续深入想，用stl的排序这题就做的没啥水平了。<br>然后想到这个整数数组平方之后最大的数一定出现在左右两端，没有负数也就只有在右边。由于题目要求升序，那就要最大放右边，那可能我还要把最右边那个数交换到其他位置上，越来越复杂了，原因在于<strong>我受上一题影响以为要在原数组上改，其实题目要返回新数组，题目没看清。</strong></p><p>思路：左右双指针，复杂度O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">re</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> end = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> lv = nums[left]*nums[left];</span><br><span class="line">        <span class="type">int</span> rv = nums[right]*nums[right];</span><br><span class="line">        <span class="keyword">if</span>(lv &gt; rv)&#123;</span><br><span class="line">            re[end--] = lv;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            re[end--] = rv;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;0、tips&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数组下标都是从0开始的。&lt;/li&gt;
&lt;li&gt;数组内存空间的地址是连续的&lt;/li&gt;
&lt;li&gt;数组的元素是不能删的，只能覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;总结：&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;学习时长：三小时。今天的题都是比较</summary>
      
    
    
    
    <category term="代码随想录算法训练营" scheme="https://photin1a.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="算法" scheme="https://photin1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机" scheme="https://photin1a.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="C++" scheme="https://photin1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>minco参数曲线化</title>
    <link href="https://photin1a.github.io/posts/58f47eff.html"/>
    <id>https://photin1a.github.io/posts/58f47eff.html</id>
    <published>2025-01-06T10:19:03.000Z</published>
    <updated>2025-01-06T10:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1>0. 微分平坦</h1><h2 id="定义">定义</h2><p>对于非线性系统的一般形式如下：<br>$$\dot x = f(x,u,t)$$<br>如果系统这个系统通过化简或者变换后能够找到一组变量$y$，使得系统的状态量$x$和控制量$u$可以由$y$及$y$的多阶导数表示，则<strong>系统是微分平坦</strong>的。即：<br>$$<br>\begin{matrix}<br>x = t_1(y,y^{‘},…,y^{n})\<br>u = t_2(y,y^{’},…,y^{n})<br>\end{matrix}<br>$$</p><h2 id="例子">例子</h2><p>例如一个常见的二自由度自行车模型，它的运动学模型和微分平坦模型的一般形式如下：<br>$$<br>\left{\begin{matrix}<br>\dot x = vcos\theta \<br>\dot y = vsin\theta \<br>\dot \theta = \frac{vtan(\delta)}{L}\<br>\dot v = a_t \<br>k = \frac{tan(\delta)}{L} \<br>a_n = v^2\cdot k<br>\end{matrix}\right.<br>$$</p><ul><li>其中$(x,y,\theta)$是状态量，代表车体的位置和航向角</li><li>$(a_t,\delta)$是控制量，代表车的纵向加速度和前轮转角</li><li>$(k,a_n)$是曲率和向心加速度</li></ul><p><strong>它的微分平坦模型如下：</strong><br>$$\left{<br>\begin{array}<br>{l}v=\eta\sqrt{\dot{x}^{2}+\dot{y}^{2}} \<br>\psi=arctan2(\eta\dot{y},\eta\dot{x}) \<br>a_{t}=\eta\frac{(\dot{x}\dot{x}+\dot{y}\dot{y})}{\sqrt{\dot{x}^{2}+\dot{y}^{2}}} \<br>\theta=arctan\mathrm{~}\eta L\frac{\dot{x}\ddot{y}-\dot{y}\ddot{x}}{(\dot{x}^{2}+\dot{y}^{2})^{\frac{3}{2}}} \<br>k=\eta\frac{\dot{x}\dot{y}-\dot{y}\ddot{x}}{(\dot{x}^{2}+y^{2})^{\frac{3}{2}}} \<br>a_{n}=\eta\frac{\dot{x}\dot{y}-\dot{y}\ddot{x}}{\sqrt{\dot{x}^{2}+\dot{y}^{2}}} \<br>\dot{\theta}=\eta L\frac{(\dot{x}\ddot{y}-\dot{y}\ddot{x})(\dot{x}^{2}+\dot{y}^{2})^{\frac{3}{2}}-3(\dot{x}\ddot{y}-\dot{y}\ddot{x})(\dot{x}^{2}+\dot{y}^{2})^{\frac{1}{2}}(\dot{x}\ddot{x}+\dot{y}\dot{y})}{(\dot{x}^{2}+\dot{y}^{2})^{3}+L^{2}(\dot{x}\ddot{y}-\dot{y}\dot{x})^{2}}<br>\end{array}\right.$$</p><ul><li>其中$\eta \in {-1,1}$，-1表示车辆倒车运动，1表示前进行驶。</li></ul><blockquote><p><a href="https://photin1a.github.io/2025/01/06/%E6%9B%B2%E7%8E%87%E7%9A%84%E5%AE%9A%E4%B9%89/">曲率的定义</a><br><a href="https://zhuanlan.zhihu.com/p/673869620">自行车微分平坦模型</a></p></blockquote><hr><h1>1. BVP（Boundary Value Problem）</h1><p><strong>定义</strong>：最优控制中的边值问题（BVP）是指在给定初始和终止条件下，求解最优控制问题的控制策略和状态轨迹的一种方法。</p><blockquote><p><strong>BVP：</strong> 一个两点（起点、终点）状态已知，求中间最优序列的问题。</p></blockquote><h2 id="1-1-最优性条件">1.1 最优性条件</h2><p>$$ min\int_0^Tv(t)^TWv(t)dt $$<br>$$ s.t.  z^{s}(t)=v(t), \forall  t \in [0,T], $$<br>$$ z^{[s-1]}(t_0)=\bar z_{o},z^{[s-1]}(t_M)=\bar z_{f}.$$</p><p>对于以上 $minmum \ control$ 问题，若系统是<strong>微分平坦</strong>的，且最小控制量是平坦变量的 $s$ <strong>阶次导数</strong>，则 $BVP$问题的最优解是一个 $2s-1$ <strong>次多项式</strong>。</p><!-- ||$x$|$v$|$a$|$jerk$|$snap$|...||---|---|---|---|---|---|---||阶次$s$|0|1|2|3|4|...|$ploy\ 2s-1$|0|1|3|5|7|...|| --><h2 id="1-2-BVP">1.2 BVP</h2><p>对于一个 $minJerk$ 问题，它的最优解是一个5次多项式，通过起点终点只有唯一解。<br>$$\beta (t) = \mathbf{\lambda}_t^T\cdot\mathbf{c} = c_0+c_1t+c_2t^2+c_3t^3+c_4t^4+c_5t^5=[1\ t\ \ t^2\ t^3\ t^4\ t^5]\cdot[c_0\ c_1\ c_2\ c_3\ c_4\ c_5]^T$$</p><p>$$\begin{bmatrix}<br>\beta(0)\<br>\beta^{‘}(0)\<br>\beta^{’‘}(0)\<br>\beta(T)\<br>\beta^{’}(T)\<br>\beta^{‘’}(T)<br>\end{bmatrix}=<br>\begin{bmatrix}<br>\lambda_0^T\<br>\lambda_0^{(1)T}\<br>\lambda_0^{(2)T}\<br>\lambda_T^T\<br>\lambda_T^{(1)T}\<br>\lambda_T^{(2)T}<br>\end{bmatrix}\cdot \mathbf{c}=<br>\begin{bmatrix}<br>1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\<br>0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0\<br>0 &amp;0 &amp;2 &amp;0 &amp;0 &amp;0\<br>1 &amp;T &amp;T^2 &amp;T^3 &amp;T^4 &amp;T^5\<br>0 &amp;1 &amp;2T &amp;3T^2 &amp;4T^3 &amp;5T^4\<br>0 &amp;0 &amp;2 &amp;6T &amp;12T^2 &amp;20T^3<br>\end{bmatrix}\cdot \mathbf{c}=\begin{bmatrix}<br>x_0\<br>v_0\<br>a_0\<br>x_T\<br>v_T\<br>a_T\<br>\end{bmatrix} \Longrightarrow A(0,T)\mathbf{c}=\mathbf{b}(0,T)$$<br>$$\mathbf c = A^{-1}\cdot \mathbf{b}(0,T)$$</p><h1>2. BIVP（Boundary  Intermediate Value Problem）</h1><blockquote><p><strong>BIVP：</strong> 一个两点（起点、终点）状态已知，中间 waypoints 已知，求中间最优轨线的问题。</p></blockquote><h2 id="2-1-最优性条件">2.1 最优性条件</h2><p>$$ min\int_{t_0}^{t_M}v(t)^TWv(t)dt $$<br>$$ s.t. \ \<br>\begin{aligned}<br>z^{s}(t)=v(t), \forall  t \in [t_0,t_M], \<br>z^{[s-1]}(t_0)=\bar z_{o},z^{[s-1]}(t_M)=\bar z_{f},\<br>z^{[d_i-1]}(t_i)=\bar z_{i},\ 1 \le i \le M,\<br>t_{i-1} \le t_i, \ 1 \le i \le M.<br>\end{aligned}<br>$$</p><p>对于以上 $minmum \ control$ 问题，若系统是<strong>微分平坦</strong>的，且最小控制量是平坦变量的 $s$ <strong>阶次导数</strong>，则 $BIVP$问题的最优解的每一段都是一个 $2s-1$ <strong>次多项式</strong>,且具有大于 $s$ 阶的连续性。$minJerk$ 具有 $snap(4)$ 阶的连续性，$minSnap$具有 $pop(6)$ 阶的连续性</p><h2 id="2-2-BIVP">2.2 BIVP</h2><p>对于 $minJerk$ 的BIVP问题。假设每段轨迹的时间 $T_i$ 已知，所有的waypoints状态已知，则waypoints和连续性约束可以表示为：</p><p>$$\beta (t) = \mathbf{\lambda}_t^T\cdot\mathbf{c} = c_0+c_1t+c_2t^2+c_3t^3+c_4t^4+c_5t^5=[1\ t\ \ t^2\ t^3\ t^4\ t^5]\cdot[c_0\ c_1\ c_2\ c_3\ c_4\ c_5]^T$$</p><p>$$<br>\begin{bmatrix}<br>\beta(t)\<br>\beta^{‘}(t)\<br>\beta^{’‘}(t)\<br>\beta^{’‘’}(t)\<br>\beta^{‘’‘’}(t)<br>\end{bmatrix}=<br>\begin{bmatrix}<br>\lambda_t^T\<br>\lambda_t^{(1)T}\<br>\lambda_t^{(2)T}\<br>\lambda_t^{(3)T}\<br>\lambda_t^{(4)T}<br>\end{bmatrix}\cdot \mathbf{c}=<br>\begin{bmatrix}<br>1 &amp;t &amp;t^2 &amp;t^3 &amp;t^4 &amp;t^5\<br>0 &amp;1 &amp;2t &amp;3t^2 &amp;4t^3 &amp;5t^4\<br>0 &amp;0 &amp;2 &amp;6t &amp;12t^2 &amp;20t^3\<br>0 &amp;0 &amp;0 &amp;6 &amp;24t &amp;60t^2\<br>0 &amp;0 &amp;0 &amp;0 &amp;24 &amp;120t<br>\end{bmatrix}\cdot \mathbf{c} = \begin{bmatrix}<br>x(t)\<br>v(t)\<br>a(t)\<br>jerk(t)\<br>snap(t)\<br>\end{bmatrix}\Longrightarrow G(t)\mathbf{c}=\mathbf{b}(t)$$</p><p>$$<br>\begin{bmatrix}<br>\beta(T_i) &amp;0\<br>G(T_i) &amp;-G(0)<br>\end{bmatrix}\cdot \begin{bmatrix}<br>\mathbf{c}(i)\<br>\mathbf{c}(i+1)\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>\mathbf{b}(T_i)\<br>0<br>\end{bmatrix}<br>\Longrightarrow<br>\begin{bmatrix}<br>E_i,F_i<br>\end{bmatrix}\cdot \begin{bmatrix}<br>\mathbf{c}(i)\<br>\mathbf{c}(i+1)\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>\mathbf{b}(i)\<br>0<br>\end{bmatrix}<br>$$<br><strong>定理：设共有 $M$ 段轨迹 ${1,…,M}$，特别定义 $F_0=A(0)$ 和 $E_M=A(T_M)$ , $b_a,b_M$ 分别为起点、终点状态。BIVP最优解由以下线性方程组唯一确定。</strong><br>$$<br>M_{2Ms*2Ms}\mathbf{c}=b \Longrightarrow \left(\begin{array}{ccccc}<br>\mathbf{F}<em>{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{0} \<br>\mathbf{E}</em>{1} &amp; \mathbf{F}<em>{1} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{0} \<br>\mathbf{0} &amp; \mathbf{E}</em>{2} &amp; \mathbf{F}<em>{2} &amp; \cdots &amp; \mathbf{0} \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\mathbf{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{F}</em>{M-1} \<br>\mathbf{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{E}_{M}<br>\end{array}\right) \cdot \begin{bmatrix}<br>\mathbf{c}_1\<br>\mathbf{c}_2\<br>\mathbf{c}<em>3\<br>\vdots\<br>\mathbf{c}</em>{M-1}\<br>\mathbf{c}_M\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>b_0\<br>b(1)\<br>0\<br>\vdots\<br>0\<br>b_M\<br>\end{bmatrix}<br>$$<br>拓展：对于三维或者多维平坦变量的参数化，满足 $M\cdot[\mathbf{c}_x,\mathbf{c}_y,\mathbf{c}_z]=[\mathbf{b}_x,\mathbf{b}_y,\mathbf{b}_z]$</p><h2 id="3-时空形变轨迹规划">3. 时空形变轨迹规划</h2><p><img src="/tra.png" alt=""></p><h3 id="3-1-概念">3.1 概念</h3><p>考虑一个更general的轨迹优化问题：<br>$$<br>\begin{aligned}<br>\min <em>{z(t),{T}} \int</em>{0}^{T} v(t)^{\mathrm{T}} \mathbf{W} v(t) \mathrm{d} t+\rho(T) \<br>\text { s. t. } z^{(s)}(t)=\bar{v}(t), \forall t \in[0, T] \text {, } \<br>\mathcal{G}\left(z(t), \cdots, z^{(s)}(t)\right) \preceq \mathbf{0}, \forall t \in[0, T] \text {, } \<br>z(t) \in\mathcal{F}, \forall t \in[0, T] \text {, } \<br>z^{[s-1]}(0)=\bar{z}<em>{o}, z^{[s-1]}(T)=\bar{z}</em>{f} \text {, } \<br>z^{[s-1]}:=\left(z^{\mathrm{T}}, \dot{z}^{\mathrm{T}}, \cdots, z^{(s-1)^{\mathrm{T}}}\right)^{\mathrm{T}} . \<br>\end{aligned}<br>$$</p><p><strong>几个问题：</strong></p><ul><li>最优解的参数化形式是未知的。</li><li>space-time 增大了问题维度</li><li>动态可行性约束是非凸的</li><li>安全区域是高复杂度的</li></ul><p><strong>可能的解决方法：</strong></p><ul><li>仍然使用参数化样条，虽然它可能不是最优的</li><li>仅仅优化空间，把时间分配固定下来</li><li>简化动力学，只考虑速度、加速度，不考虑角速度等底层的约束</li><li>尽量简化安全性约束，使得它是局部凸的</li></ul><h3 id="3-2-轨迹参数化">3.2 轨迹参数化</h3><p>每段轨迹的 $T_i$ 未知，waypoints未知或部分已知，例如只知道 $(x,y)$ 。<br>$$<br>\begin{aligned}<br>\min <em>{z(t), T} &amp; \int</em>{0}^{T} v(t)^{\mathrm{T}} \mathbf{W} v(t) \mathrm{d} t+\rho(T), \<br>\text { s.t. } &amp; v(t)=z^{(s)}(t), \forall t \in[0, T], \<br>&amp; \mathcal{G}\left(z(t), \ldots, z^{(s)}(t)\right) \preceq \mathbf{0}, \forall t \in[0, T], \<br>&amp; z(t) \in \mathcal{F}, \forall t \in[0, T], \<br>&amp; z^{[s-1]}(0)=\bar{z}<em>{o}, z^{[s-1]}(T)=\bar{z}</em>{f}, \<br>&amp; z^{[s-1]}=\left(z^{\mathrm{T}}, \dot{z}^{\mathrm{T}}, \ldots, z^{(s-1)^{\mathrm{T}}}\right)^{\mathrm{T}}<br>\end{aligned}<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;0. 微分平坦&lt;/h1&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;对于非线性系统的一般形式如下：&lt;br&gt;
$$&#92;dot x = f(x,u,t)$$&lt;br&gt;
如果系统这个系统通过化简或者变换后能够找到一组变量$y$，使得系统的状态量$x$和控制量$u$可以由$y$及</summary>
      
    
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/categories/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/tags/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>曲率的定义</title>
    <link href="https://photin1a.github.io/posts/41c0672e.html"/>
    <id>https://photin1a.github.io/posts/41c0672e.html</id>
    <published>2025-01-06T01:47:56.000Z</published>
    <updated>2025-01-06T01:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、曲率的定义</h1><p>曲率（Curvature）是描述曲线弯曲程度的量度。在二维空间中，对于一条曲线，曲率在某一点上可以通过以下公式计算：<br>$$<br>\kappa = \frac{d\theta}{ds}<br>$$<br>其中：</p><ul><li><code>dθ</code>是曲线的切线方向（即车辆朝向）相对于路径切线的变化量。</li><li><code>ds</code>是路径上的微小弧长增量。</li></ul><h1>2、曲率的大小和方向</h1><ul><li><strong>大小：</strong> 曲率的大小表示曲线弯曲的程度，曲线弯曲的越大，其曲率越大。</li><li><strong>方向：</strong> 曲率的正负决定了路径的弯曲方向。遵循<strong>右手定则</strong>，正曲率表示曲线逆时针弯曲，负曲率表示顺时针弯曲。</li></ul><h1>3、曲率的应用</h1><h2 id="3-1-曲率的计算">3.1 曲率的计算</h2><p>在自动驾驶中，车辆的转弯半径受到前轮转角的限制，从而影响轨迹的曲率。现在有一条正曲率的轨迹，我们分情况讨论一下曲率：<br><img src="./41c0672e/curve.png" alt=""><br><strong>case 1.</strong> 一号车的方向是顺着轨迹的，想要跟踪这条轨迹只需要保持速度为正$v&gt;0$并向左打方向盘，$\delta&gt;0, tan(\delta)&gt;0$。轨迹曲率如下：<br>$$<br>\kappa = \frac{1}{R} = \frac{tan\delta}{L}<br>$$<br><strong>case 2.</strong> 二号车的方向是相反轨迹的，想要跟踪这条轨迹则需要倒车，$v&lt;0$ 并向右打方向盘，$\delta&lt;0,tan(\delta)&lt;0$。轨迹曲率如下：<br>$$<br>\kappa = -\frac{tan\delta}{L}<br>$$</p><p><strong>总结：</strong><br>综上，轨迹的曲率与车辆的运动关系可以表示为如下形式，$sign$ 是符号函数。<br>$$<br>\kappa = sign(v)\cdot \frac{tan\delta}{L}<br>$$</p><blockquote><p>上述公式同样适用于其他非完整模型车辆</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、曲率的定义&lt;/h1&gt;
&lt;p&gt;曲率（Curvature）是描述曲线弯曲程度的量度。在二维空间中，对于一条曲线，曲率在某一点上可以通过以下公式计算：&lt;br&gt;
$$&lt;br&gt;
&#92;kappa = &#92;frac{d&#92;theta}{ds}&lt;br&gt;
$$&lt;br&gt;
其中：&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/categories/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
    
    <category term="轨迹规划" scheme="https://photin1a.github.io/tags/%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
